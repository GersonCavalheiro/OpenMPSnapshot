#ifndef GCC_TREE_H
#define GCC_TREE_H
#include "tree-core.h"
inline combined_fn
as_combined_fn (built_in_function fn)
{
return combined_fn (int (fn));
}
inline combined_fn
as_combined_fn (internal_fn fn)
{
return combined_fn (int (fn) + int (END_BUILTINS));
}
inline bool
builtin_fn_p (combined_fn code)
{
return int (code) < int (END_BUILTINS);
}
inline built_in_function
as_builtin_fn (combined_fn code)
{
gcc_checking_assert (builtin_fn_p (code));
return built_in_function (int (code));
}
inline bool
internal_fn_p (combined_fn code)
{
return int (code) >= int (END_BUILTINS);
}
inline internal_fn
as_internal_fn (combined_fn code)
{
gcc_checking_assert (internal_fn_p (code));
return internal_fn (int (code) - int (END_BUILTINS));
}
#define MARK_TS_BASE(C)					\
(tree_contains_struct[C][TS_BASE] = true)
#define MARK_TS_TYPED(C)				\
(MARK_TS_BASE (C),					\
tree_contains_struct[C][TS_TYPED] = true)
#define MARK_TS_COMMON(C)				\
(MARK_TS_TYPED (C),					\
tree_contains_struct[C][TS_COMMON] = true)
#define MARK_TS_TYPE_COMMON(C)				\
(MARK_TS_COMMON (C),					\
tree_contains_struct[C][TS_TYPE_COMMON] = true)
#define MARK_TS_TYPE_WITH_LANG_SPECIFIC(C)		\
(MARK_TS_TYPE_COMMON (C),				\
tree_contains_struct[C][TS_TYPE_WITH_LANG_SPECIFIC] = true)
#define MARK_TS_DECL_MINIMAL(C)				\
(MARK_TS_COMMON (C),					\
tree_contains_struct[C][TS_DECL_MINIMAL] = true)
#define MARK_TS_DECL_COMMON(C)				\
(MARK_TS_DECL_MINIMAL (C),				\
tree_contains_struct[C][TS_DECL_COMMON] = true)
#define MARK_TS_DECL_WRTL(C)				\
(MARK_TS_DECL_COMMON (C),				\
tree_contains_struct[C][TS_DECL_WRTL] = true)
#define MARK_TS_DECL_WITH_VIS(C)			\
(MARK_TS_DECL_WRTL (C),				\
tree_contains_struct[C][TS_DECL_WITH_VIS] = true)
#define MARK_TS_DECL_NON_COMMON(C)			\
(MARK_TS_DECL_WITH_VIS (C),				\
tree_contains_struct[C][TS_DECL_NON_COMMON] = true)
#define TREE_CODE_CLASS_STRING(CLASS)\
tree_code_class_strings[(int) (CLASS)]
#define TREE_CODE_CLASS(CODE)	tree_code_type[(int) (CODE)]
#define EXCEPTIONAL_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_exceptional)
#define CONSTANT_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_constant)
#define TYPE_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_type)
#define DECL_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_declaration)
#define VAR_P(NODE) \
(TREE_CODE (NODE) == VAR_DECL)
#define VAR_OR_FUNCTION_DECL_P(DECL)\
(TREE_CODE (DECL) == VAR_DECL || TREE_CODE (DECL) == FUNCTION_DECL)
#define INDIRECT_REF_P(NODE)\
(TREE_CODE (NODE) == INDIRECT_REF)
#define REFERENCE_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_reference)
#define COMPARISON_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_comparison)
#define UNARY_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_unary)
#define BINARY_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_binary)
#define STATEMENT_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_statement)
#define VL_EXP_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_vl_exp)
#define EXPRESSION_CLASS_P(NODE)\
(TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_expression)
#define IS_TYPE_OR_DECL_P(NODE)\
(TYPE_P (NODE) || DECL_P (NODE))
#define IS_EXPR_CODE_CLASS(CLASS)\
((CLASS) >= tcc_reference && (CLASS) <= tcc_expression)
#define EXPR_P(NODE) IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))
#define TREE_CODE_LENGTH(CODE)	tree_code_length[(int) (CODE)]
#define CASE_FLT_FN(FN) case FN: case FN##F: case FN##L
#define CASE_FLT_FN_FLOATN_NX(FN)			   \
case FN##F16: case FN##F32: case FN##F64: case FN##F128: \
case FN##F32X: case FN##F64X: case FN##F128X
#define CASE_FLT_FN_REENT(FN) case FN##_R: case FN##F_R: case FN##L_R
#define CASE_INT_FN(FN) case FN: case FN##L: case FN##LL: case FN##IMAX
#define NULL_TREE (tree) NULL
#define TREE_CODE(NODE) ((enum tree_code) (NODE)->base.code)
#define TREE_SET_CODE(NODE, VALUE) ((NODE)->base.code = (VALUE))
#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)
#define TREE_CHECK(T, CODE) \
(tree_check ((T), __FILE__, __LINE__, __FUNCTION__, (CODE)))
#define TREE_NOT_CHECK(T, CODE) \
(tree_not_check ((T), __FILE__, __LINE__, __FUNCTION__, (CODE)))
#define TREE_CHECK2(T, CODE1, CODE2) \
(tree_check2 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2)))
#define TREE_NOT_CHECK2(T, CODE1, CODE2) \
(tree_not_check2 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2)))
#define TREE_CHECK3(T, CODE1, CODE2, CODE3) \
(tree_check3 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2), (CODE3)))
#define TREE_NOT_CHECK3(T, CODE1, CODE2, CODE3) \
(tree_not_check3 ((T), __FILE__, __LINE__, __FUNCTION__, \
(CODE1), (CODE2), (CODE3)))
#define TREE_CHECK4(T, CODE1, CODE2, CODE3, CODE4) \
(tree_check4 ((T), __FILE__, __LINE__, __FUNCTION__, \
(CODE1), (CODE2), (CODE3), (CODE4)))
#define TREE_NOT_CHECK4(T, CODE1, CODE2, CODE3, CODE4) \
(tree_not_check4 ((T), __FILE__, __LINE__, __FUNCTION__, \
(CODE1), (CODE2), (CODE3), (CODE4)))
#define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) \
(tree_check5 ((T), __FILE__, __LINE__, __FUNCTION__, \
(CODE1), (CODE2), (CODE3), (CODE4), (CODE5)))
#define TREE_NOT_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) \
(tree_not_check5 ((T), __FILE__, __LINE__, __FUNCTION__, \
(CODE1), (CODE2), (CODE3), (CODE4), (CODE5)))
#define CONTAINS_STRUCT_CHECK(T, STRUCT) \
(contains_struct_check ((T), (STRUCT), __FILE__, __LINE__, __FUNCTION__))
#define TREE_CLASS_CHECK(T, CLASS) \
(tree_class_check ((T), (CLASS), __FILE__, __LINE__, __FUNCTION__))
#define TREE_RANGE_CHECK(T, CODE1, CODE2) \
(tree_range_check ((T), (CODE1), (CODE2), __FILE__, __LINE__, __FUNCTION__))
#define OMP_CLAUSE_SUBCODE_CHECK(T, CODE) \
(omp_clause_subcode_check ((T), (CODE), __FILE__, __LINE__, __FUNCTION__))
#define OMP_CLAUSE_RANGE_CHECK(T, CODE1, CODE2) \
(omp_clause_range_check ((T), (CODE1), (CODE2), \
__FILE__, __LINE__, __FUNCTION__))
#define EXPR_CHECK(T) \
(expr_check ((T), __FILE__, __LINE__, __FUNCTION__))
#define NON_TYPE_CHECK(T) \
(non_type_check ((T), __FILE__, __LINE__, __FUNCTION__))
#define ANY_INTEGRAL_TYPE_CHECK(T) \
(any_integral_type_check ((T), __FILE__, __LINE__, __FUNCTION__))
#define TREE_INT_CST_ELT_CHECK(T, I) \
(*tree_int_cst_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))
#define TREE_VEC_ELT_CHECK(T, I) \
(*(CONST_CAST2 (tree *, typeof (T)*, \
tree_vec_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))))
#define OMP_CLAUSE_ELT_CHECK(T, I) \
(*(omp_clause_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__)))
#define TREE_OPERAND_CHECK(T, I) \
(*(CONST_CAST2 (tree*, typeof (T)*, \
tree_operand_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))))
#define TREE_OPERAND_CHECK_CODE(T, CODE, I) \
(*(tree_operand_check_code ((T), (CODE), (I), \
__FILE__, __LINE__, __FUNCTION__)))
#define TREE_CHAIN(NODE) \
(CONTAINS_STRUCT_CHECK (NODE, TS_COMMON)->common.chain)
#define TREE_TYPE(NODE) \
(CONTAINS_STRUCT_CHECK (NODE, TS_TYPED)->typed.type)
extern void tree_contains_struct_check_failed (const_tree,
const enum tree_node_structure_enum,
const char *, int, const char *)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void tree_check_failed (const_tree, const char *, int, const char *,
...) ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void tree_not_check_failed (const_tree, const char *, int, const char *,
...) ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void tree_class_check_failed (const_tree, const enum tree_code_class,
const char *, int, const char *)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void tree_range_check_failed (const_tree, const char *, int,
const char *, enum tree_code,
enum tree_code)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void tree_not_class_check_failed (const_tree,
const enum tree_code_class,
const char *, int, const char *)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void tree_int_cst_elt_check_failed (int, int, const char *,
int, const char *)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void tree_vec_elt_check_failed (int, int, const char *,
int, const char *)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void phi_node_elt_check_failed (int, int, const char *,
int, const char *)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void tree_operand_check_failed (int, const_tree,
const char *, int, const char *)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void omp_clause_check_failed (const_tree, const char *, int,
const char *, enum omp_clause_code)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void omp_clause_operand_check_failed (int, const_tree, const char *,
int, const char *)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
extern void omp_clause_range_check_failed (const_tree, const char *, int,
const char *, enum omp_clause_code,
enum omp_clause_code)
ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
#else 
#define CONTAINS_STRUCT_CHECK(T, ENUM)          (T)
#define TREE_CHECK(T, CODE)			(T)
#define TREE_NOT_CHECK(T, CODE)			(T)
#define TREE_CHECK2(T, CODE1, CODE2)		(T)
#define TREE_NOT_CHECK2(T, CODE1, CODE2)	(T)
#define TREE_CHECK3(T, CODE1, CODE2, CODE3)	(T)
#define TREE_NOT_CHECK3(T, CODE1, CODE2, CODE3)	(T)
#define TREE_CHECK4(T, CODE1, CODE2, CODE3, CODE4) (T)
#define TREE_NOT_CHECK4(T, CODE1, CODE2, CODE3, CODE4) (T)
#define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) (T)
#define TREE_NOT_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) (T)
#define TREE_CLASS_CHECK(T, CODE)		(T)
#define TREE_RANGE_CHECK(T, CODE1, CODE2)	(T)
#define EXPR_CHECK(T)				(T)
#define NON_TYPE_CHECK(T)			(T)
#define TREE_INT_CST_ELT_CHECK(T, I)		((T)->int_cst.val[I])
#define TREE_VEC_ELT_CHECK(T, I)		((T)->vec.a[I])
#define TREE_OPERAND_CHECK(T, I)		((T)->exp.operands[I])
#define TREE_OPERAND_CHECK_CODE(T, CODE, I)	((T)->exp.operands[I])
#define OMP_CLAUSE_ELT_CHECK(T, i)	        ((T)->omp_clause.ops[i])
#define OMP_CLAUSE_RANGE_CHECK(T, CODE1, CODE2)	(T)
#define OMP_CLAUSE_SUBCODE_CHECK(T, CODE)	(T)
#define ANY_INTEGRAL_TYPE_CHECK(T)		(T)
#define TREE_CHAIN(NODE) ((NODE)->common.chain)
#define TREE_TYPE(NODE) ((NODE)->typed.type)
#endif
#define TREE_BLOCK(NODE)		(tree_block (NODE))
#define TREE_SET_BLOCK(T, B)		(tree_set_block ((T), (B)))
#include "tree-check.h"
#define TYPE_CHECK(T)		TREE_CLASS_CHECK (T, tcc_type)
#define DECL_MINIMAL_CHECK(T)   CONTAINS_STRUCT_CHECK (T, TS_DECL_MINIMAL)
#define DECL_COMMON_CHECK(T)    CONTAINS_STRUCT_CHECK (T, TS_DECL_COMMON)
#define DECL_WRTL_CHECK(T)      CONTAINS_STRUCT_CHECK (T, TS_DECL_WRTL)
#define DECL_WITH_VIS_CHECK(T)  CONTAINS_STRUCT_CHECK (T, TS_DECL_WITH_VIS)
#define DECL_NON_COMMON_CHECK(T) CONTAINS_STRUCT_CHECK (T, TS_DECL_NON_COMMON)
#define CST_CHECK(T)		TREE_CLASS_CHECK (T, tcc_constant)
#define STMT_CHECK(T)		TREE_CLASS_CHECK (T, tcc_statement)
#define VL_EXP_CHECK(T)		TREE_CLASS_CHECK (T, tcc_vl_exp)
#define FUNC_OR_METHOD_CHECK(T)	TREE_CHECK2 (T, FUNCTION_TYPE, METHOD_TYPE)
#define PTR_OR_REF_CHECK(T)	TREE_CHECK2 (T, POINTER_TYPE, REFERENCE_TYPE)
#define RECORD_OR_UNION_CHECK(T)	\
TREE_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)
#define NOT_RECORD_OR_UNION_CHECK(T) \
TREE_NOT_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)
#define NUMERICAL_TYPE_CHECK(T)					\
TREE_CHECK5 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE, REAL_TYPE,	\
FIXED_POINT_TYPE)
#define TYPE_HASH(TYPE) (TYPE_UID (TYPE))
#define TREE_HASH(NODE) ((size_t) (NODE) & 0777777)
#define CONVERT_EXPR_CODE_P(CODE)				\
((CODE) == NOP_EXPR || (CODE) == CONVERT_EXPR)
#define CONVERT_EXPR_P(EXP)	CONVERT_EXPR_CODE_P (TREE_CODE (EXP))
#define CASE_CONVERT						\
case NOP_EXPR:						\
case CONVERT_EXPR
#define STRIP_NOPS(EXP) \
(EXP) = tree_strip_nop_conversions (CONST_CAST_TREE (EXP))
#define STRIP_SIGN_NOPS(EXP) \
(EXP) = tree_strip_sign_nop_conversions (CONST_CAST_TREE (EXP))
#define STRIP_TYPE_NOPS(EXP) \
while ((CONVERT_EXPR_P (EXP)					\
|| TREE_CODE (EXP) == NON_LVALUE_EXPR)		\
&& TREE_OPERAND (EXP, 0) != error_mark_node		\
&& (TREE_TYPE (EXP)					\
== TREE_TYPE (TREE_OPERAND (EXP, 0))))		\
(EXP) = TREE_OPERAND (EXP, 0)
#define STRIP_USELESS_TYPE_CONVERSION(EXP) \
(EXP) = tree_ssa_strip_useless_type_conversions (EXP)
#define STRIP_ANY_LOCATION_WRAPPER(EXP) \
(EXP) = tree_strip_any_location_wrapper (CONST_CAST_TREE (EXP))
#define VECTOR_TYPE_P(TYPE) (TREE_CODE (TYPE) == VECTOR_TYPE)
#define VECTOR_BOOLEAN_TYPE_P(TYPE)				\
(TREE_CODE (TYPE) == VECTOR_TYPE			\
&& TREE_CODE (TREE_TYPE (TYPE)) == BOOLEAN_TYPE)
#define INTEGRAL_TYPE_P(TYPE)  \
(TREE_CODE (TYPE) == ENUMERAL_TYPE  \
|| TREE_CODE (TYPE) == BOOLEAN_TYPE \
|| TREE_CODE (TYPE) == INTEGER_TYPE)
#define ANY_INTEGRAL_TYPE_P(TYPE)		\
(INTEGRAL_TYPE_P (TYPE)			\
|| ((TREE_CODE (TYPE) == COMPLEX_TYPE 	\
|| VECTOR_TYPE_P (TYPE))		\
&& INTEGRAL_TYPE_P (TREE_TYPE (TYPE))))
#define NON_SAT_FIXED_POINT_TYPE_P(TYPE) \
(TREE_CODE (TYPE) == FIXED_POINT_TYPE && !TYPE_SATURATING (TYPE))
#define SAT_FIXED_POINT_TYPE_P(TYPE) \
(TREE_CODE (TYPE) == FIXED_POINT_TYPE && TYPE_SATURATING (TYPE))
#define FIXED_POINT_TYPE_P(TYPE)	(TREE_CODE (TYPE) == FIXED_POINT_TYPE)
#define SCALAR_FLOAT_TYPE_P(TYPE) (TREE_CODE (TYPE) == REAL_TYPE)
#define COMPLEX_FLOAT_TYPE_P(TYPE)	\
(TREE_CODE (TYPE) == COMPLEX_TYPE	\
&& TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE)
#define VECTOR_INTEGER_TYPE_P(TYPE)			\
(VECTOR_TYPE_P (TYPE)					\
&& TREE_CODE (TREE_TYPE (TYPE)) == INTEGER_TYPE)
#define VECTOR_FLOAT_TYPE_P(TYPE)	\
(VECTOR_TYPE_P (TYPE)			\
&& TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE)
#define FLOAT_TYPE_P(TYPE)			\
(SCALAR_FLOAT_TYPE_P (TYPE)			\
|| ((TREE_CODE (TYPE) == COMPLEX_TYPE 	\
|| VECTOR_TYPE_P (TYPE))		\
&& SCALAR_FLOAT_TYPE_P (TREE_TYPE (TYPE))))
#define DECIMAL_FLOAT_TYPE_P(TYPE)		\
(SCALAR_FLOAT_TYPE_P (TYPE)			\
&& DECIMAL_FLOAT_MODE_P (TYPE_MODE (TYPE)))
#define RECORD_OR_UNION_TYPE_P(TYPE)		\
(TREE_CODE (TYPE) == RECORD_TYPE		\
|| TREE_CODE (TYPE) == UNION_TYPE		\
|| TREE_CODE (TYPE) == QUAL_UNION_TYPE)
#define AGGREGATE_TYPE_P(TYPE) \
(TREE_CODE (TYPE) == ARRAY_TYPE || RECORD_OR_UNION_TYPE_P (TYPE))
#define POINTER_TYPE_P(TYPE) \
(TREE_CODE (TYPE) == POINTER_TYPE || TREE_CODE (TYPE) == REFERENCE_TYPE)
#define FUNCTION_POINTER_TYPE_P(TYPE) \
(POINTER_TYPE_P (TYPE) && TREE_CODE (TREE_TYPE (TYPE)) == FUNCTION_TYPE)
#define COMPLETE_TYPE_P(NODE) (TYPE_SIZE (NODE) != NULL_TREE)
#define POINTER_BOUNDS_TYPE_P(NODE) \
(TREE_CODE (NODE) == POINTER_BOUNDS_TYPE)
#define POINTER_BOUNDS_P(NODE) \
(POINTER_BOUNDS_TYPE_P (TREE_TYPE (NODE)))
#define BOUNDED_TYPE_P(type) (POINTER_TYPE_P (type))
#define BOUNDED_P(node) \
BOUNDED_TYPE_P (TREE_TYPE (node))
#define VOID_TYPE_P(NODE) (TREE_CODE (NODE) == VOID_TYPE)
#define COMPLETE_OR_VOID_TYPE_P(NODE) \
(COMPLETE_TYPE_P (NODE) || VOID_TYPE_P (NODE))
#define COMPLETE_OR_UNBOUND_ARRAY_TYPE_P(NODE) \
(COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : (NODE)))
#define FUNC_OR_METHOD_TYPE_P(NODE) \
(TREE_CODE (NODE) == FUNCTION_TYPE || TREE_CODE (NODE) == METHOD_TYPE)
#define TREE_ADDRESSABLE(NODE) ((NODE)->base.addressable_flag)
#define CALL_EXPR_TAILCALL(NODE) \
(CALL_EXPR_CHECK (NODE)->base.addressable_flag)
#define CALL_EXPR_MUST_TAIL_CALL(NODE) \
(CALL_EXPR_CHECK (NODE)->base.static_flag)
#define CASE_LOW_SEEN(NODE) \
(CASE_LABEL_EXPR_CHECK (NODE)->base.addressable_flag)
#define PREDICT_EXPR_OUTCOME(NODE) \
((enum prediction) (PREDICT_EXPR_CHECK (NODE)->base.addressable_flag))
#define SET_PREDICT_EXPR_OUTCOME(NODE, OUTCOME) \
(PREDICT_EXPR_CHECK (NODE)->base.addressable_flag = (int) OUTCOME)
#define PREDICT_EXPR_PREDICTOR(NODE) \
((enum br_predictor)tree_to_shwi (TREE_OPERAND (PREDICT_EXPR_CHECK (NODE), 0)))
#define TREE_STATIC(NODE) ((NODE)->base.static_flag)
#define TREE_NO_TRAMPOLINE(NODE) (ADDR_EXPR_CHECK (NODE)->base.static_flag)
#define CLEANUP_EH_ONLY(NODE) ((NODE)->base.static_flag)
#define TRY_CATCH_IS_CLEANUP(NODE) \
(TRY_CATCH_EXPR_CHECK (NODE)->base.static_flag)
#define CASE_HIGH_SEEN(NODE) \
(CASE_LABEL_EXPR_CHECK (NODE)->base.static_flag)
#define ENUM_IS_SCOPED(NODE) (ENUMERAL_TYPE_CHECK (NODE)->base.static_flag)
#define ENUM_IS_OPAQUE(NODE) (ENUMERAL_TYPE_CHECK (NODE)->base.private_flag)
#define TREE_NO_WARNING(NODE) ((NODE)->base.nowarning_flag)
#define TRANSLATION_UNIT_WARN_EMPTY_P(NODE) \
(TRANSLATION_UNIT_DECL_CHECK (NODE)->decl_common.decl_flag_0)
#define TYPE_EMPTY_P(NODE) (TYPE_CHECK (NODE)->type_common.empty_flag)
#define TYPE_ARTIFICIAL(NODE) (TYPE_CHECK (NODE)->base.nowarning_flag)
#define TREE_SYMBOL_REFERENCED(NODE) \
(IDENTIFIER_NODE_CHECK (NODE)->base.static_flag)
#define TYPE_REF_CAN_ALIAS_ALL(NODE) \
(PTR_OR_REF_CHECK (NODE)->base.static_flag)
#define TREE_OVERFLOW(NODE) (CST_CHECK (NODE)->base.public_flag)
#define TREE_OVERFLOW_P(EXPR) \
(CONSTANT_CLASS_P (EXPR) && TREE_OVERFLOW (EXPR))
#define TREE_PUBLIC(NODE) ((NODE)->base.public_flag)
#define TYPE_CACHED_VALUES_P(NODE) (TYPE_CHECK (NODE)->base.public_flag)
#define SAVE_EXPR_RESOLVED_P(NODE) \
(SAVE_EXPR_CHECK (NODE)->base.public_flag)
#define CALL_EXPR_VA_ARG_PACK(NODE) \
(CALL_EXPR_CHECK (NODE)->base.public_flag)
#define TREE_SIDE_EFFECTS(NODE) \
(NON_TYPE_CHECK (NODE)->base.side_effects_flag)
#define FORCED_LABEL(NODE) (LABEL_DECL_CHECK (NODE)->base.side_effects_flag)
#define FALLTHROUGH_LABEL_P(NODE) \
(LABEL_DECL_CHECK (NODE)->base.private_flag)
#define SWITCH_BREAK_LABEL_P(NODE) \
(LABEL_DECL_CHECK (NODE)->base.protected_flag)
#define TREE_THIS_VOLATILE(NODE) ((NODE)->base.volatile_flag)
#define TREE_THIS_NOTRAP(NODE) \
(TREE_CHECK5 (NODE, INDIRECT_REF, MEM_REF, TARGET_MEM_REF, ARRAY_REF,	\
ARRAY_RANGE_REF)->base.nothrow_flag)
#define TREE_READONLY(NODE) (NON_TYPE_CHECK (NODE)->base.readonly_flag)
#define TREE_CONSTANT(NODE) (NON_TYPE_CHECK (NODE)->base.constant_flag)
#define TYPE_SIZES_GIMPLIFIED(NODE) \
(TYPE_CHECK (NODE)->base.constant_flag)
#define DECL_UNSIGNED(NODE) \
(DECL_COMMON_CHECK (NODE)->base.u.bits.unsigned_flag)
#define TYPE_UNSIGNED(NODE) (TYPE_CHECK (NODE)->base.u.bits.unsigned_flag)
#define TYPE_SIGN(NODE) ((signop) TYPE_UNSIGNED (NODE))
#define TYPE_OVERFLOW_WRAPS(TYPE) \
(POINTER_TYPE_P (TYPE)					\
? flag_wrapv_pointer						\
: (ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag	\
|| flag_wrapv))
#define TYPE_OVERFLOW_UNDEFINED(TYPE)				\
(POINTER_TYPE_P (TYPE)					\
? !flag_wrapv_pointer					\
: (!ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag	\
&& !flag_wrapv && !flag_trapv))
#define TYPE_OVERFLOW_TRAPS(TYPE) \
(!ANY_INTEGRAL_TYPE_CHECK(TYPE)->base.u.bits.unsigned_flag && flag_trapv)
#define TYPE_OVERFLOW_SANITIZED(TYPE)			\
(INTEGRAL_TYPE_P (TYPE)				\
&& !TYPE_OVERFLOW_WRAPS (TYPE)			\
&& (flag_sanitize & SANITIZE_SI_OVERFLOW))
#define TREE_ASM_WRITTEN(NODE) ((NODE)->base.asm_written_flag)
#define TREE_USED(NODE) ((NODE)->base.used_flag)
#define TREE_NOTHROW(NODE) ((NODE)->base.nothrow_flag)
#define CALL_EXPR_RETURN_SLOT_OPT(NODE) \
(CALL_EXPR_CHECK (NODE)->base.private_flag)
#define DECL_BY_REFERENCE(NODE) \
(TREE_CHECK3 (NODE, VAR_DECL, PARM_DECL, \
RESULT_DECL)->decl_common.decl_by_reference_flag)
#define DECL_READ_P(NODE) \
(TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl_common.decl_read_flag)
#define DECL_NONSHAREABLE(NODE) \
(TREE_CHECK2 (NODE, VAR_DECL, \
RESULT_DECL)->decl_common.decl_nonshareable_flag)
#define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)
#define CALL_ALLOCA_FOR_VAR_P(NODE) \
(CALL_EXPR_CHECK (NODE)->base.protected_flag)
#define CALL_WITH_BOUNDS_P(NODE) (CALL_EXPR_CHECK (NODE)->base.deprecated_flag)
#define TREE_PRIVATE(NODE) ((NODE)->base.private_flag)
#define TREE_PROTECTED(NODE) ((NODE)->base.protected_flag)
#define TYPE_REF_IS_RVALUE(NODE) \
(REFERENCE_TYPE_CHECK (NODE)->base.private_flag)
#define TREE_DEPRECATED(NODE) \
((NODE)->base.deprecated_flag)
#define IDENTIFIER_TRANSPARENT_ALIAS(NODE) \
(IDENTIFIER_NODE_CHECK (NODE)->base.deprecated_flag)
#define TYPE_REVERSE_STORAGE_ORDER(NODE) \
(TREE_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, ARRAY_TYPE)->base.u.bits.saturating_flag)
#define TYPE_SATURATING(NODE) \
(TREE_NOT_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, ARRAY_TYPE)->base.u.bits.saturating_flag)
#define REF_REVERSE_STORAGE_ORDER(NODE) \
(TREE_CHECK2 (NODE, BIT_FIELD_REF, MEM_REF)->base.default_def_flag)
#define FUNC_ADDR_BY_DESCRIPTOR(NODE) \
(TREE_CHECK (NODE, ADDR_EXPR)->base.default_def_flag)
#define CALL_EXPR_BY_DESCRIPTOR(NODE) \
(TREE_CHECK (NODE, CALL_EXPR)->base.default_def_flag)
#define TREE_LANG_FLAG_0(NODE) \
(TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_0)
#define TREE_LANG_FLAG_1(NODE) \
(TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_1)
#define TREE_LANG_FLAG_2(NODE) \
(TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_2)
#define TREE_LANG_FLAG_3(NODE) \
(TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_3)
#define TREE_LANG_FLAG_4(NODE) \
(TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_4)
#define TREE_LANG_FLAG_5(NODE) \
(TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_5)
#define TREE_LANG_FLAG_6(NODE) \
(TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_6)
#define TREE_INT_CST_NUNITS(NODE) \
(INTEGER_CST_CHECK (NODE)->base.u.int_length.unextended)
#define TREE_INT_CST_EXT_NUNITS(NODE) \
(INTEGER_CST_CHECK (NODE)->base.u.int_length.extended)
#define TREE_INT_CST_OFFSET_NUNITS(NODE) \
(INTEGER_CST_CHECK (NODE)->base.u.int_length.offset)
#define TREE_INT_CST_ELT(NODE, I) TREE_INT_CST_ELT_CHECK (NODE, I)
#define TREE_INT_CST_LOW(NODE) \
((unsigned HOST_WIDE_INT) TREE_INT_CST_ELT (NODE, 0))
#define POLY_INT_CST_P(NODE) \
(NUM_POLY_INT_COEFFS > 1 && TREE_CODE (NODE) == POLY_INT_CST)
#define POLY_INT_CST_COEFF(NODE, I) \
(POLY_INT_CST_CHECK (NODE)->poly_int_cst.coeffs[I])
#define TREE_REAL_CST_PTR(NODE) (REAL_CST_CHECK (NODE)->real_cst.real_cst_ptr)
#define TREE_REAL_CST(NODE) (*TREE_REAL_CST_PTR (NODE))
#define TREE_FIXED_CST_PTR(NODE) \
(FIXED_CST_CHECK (NODE)->fixed_cst.fixed_cst_ptr)
#define TREE_FIXED_CST(NODE) (*TREE_FIXED_CST_PTR (NODE))
#define TREE_STRING_LENGTH(NODE) (STRING_CST_CHECK (NODE)->string.length)
#define TREE_STRING_POINTER(NODE) \
((const char *)(STRING_CST_CHECK (NODE)->string.str))
#define TREE_REALPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.real)
#define TREE_IMAGPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.imag)
#define VECTOR_CST_NELTS(NODE) (TYPE_VECTOR_SUBPARTS (TREE_TYPE (NODE)))
#define VECTOR_CST_ELT(NODE,IDX) vector_cst_elt (NODE, IDX)
#define VECTOR_CST_LOG2_NPATTERNS(NODE) \
(VECTOR_CST_CHECK (NODE)->base.u.vector_cst.log2_npatterns)
#define VECTOR_CST_NPATTERNS(NODE) \
(1U << VECTOR_CST_LOG2_NPATTERNS (NODE))
#define VECTOR_CST_NELTS_PER_PATTERN(NODE) \
(VECTOR_CST_CHECK (NODE)->base.u.vector_cst.nelts_per_pattern)
#define VECTOR_CST_DUPLICATE_P(NODE) \
(VECTOR_CST_NELTS_PER_PATTERN (NODE) == 1)
#define VECTOR_CST_STEPPED_P(NODE) \
(VECTOR_CST_NELTS_PER_PATTERN (NODE) == 3)
#define VECTOR_CST_ENCODED_ELTS(NODE) \
(VECTOR_CST_CHECK (NODE)->vector.elts)
#define VECTOR_CST_ENCODED_ELT(NODE, ELT) \
(VECTOR_CST_CHECK (NODE)->vector.elts[ELT])
#define IDENTIFIER_LENGTH(NODE) \
(IDENTIFIER_NODE_CHECK (NODE)->identifier.id.len)
#define IDENTIFIER_POINTER(NODE) \
((const char *) IDENTIFIER_NODE_CHECK (NODE)->identifier.id.str)
#define IDENTIFIER_HASH_VALUE(NODE) \
(IDENTIFIER_NODE_CHECK (NODE)->identifier.id.hash_value)
#define HT_IDENT_TO_GCC_IDENT(NODE) \
((tree) ((char *) (NODE) - sizeof (struct tree_common)))
#define GCC_IDENT_TO_HT_IDENT(NODE) (&((struct tree_identifier *) (NODE))->id)
#define TREE_PURPOSE(NODE) (TREE_LIST_CHECK (NODE)->list.purpose)
#define TREE_VALUE(NODE) (TREE_LIST_CHECK (NODE)->list.value)
#define TREE_VEC_LENGTH(NODE) (TREE_VEC_CHECK (NODE)->base.u.length)
#define TREE_VEC_END(NODE) \
((void) TREE_VEC_CHECK (NODE), &((NODE)->vec.a[(NODE)->vec.base.u.length]))
#define TREE_VEC_ELT(NODE,I) TREE_VEC_ELT_CHECK (NODE, I)
#define CONSTRUCTOR_ELTS(NODE) (CONSTRUCTOR_CHECK (NODE)->constructor.elts)
#define CONSTRUCTOR_ELT(NODE,IDX) \
(&(*CONSTRUCTOR_ELTS (NODE))[IDX])
#define CONSTRUCTOR_NELTS(NODE) \
(vec_safe_length (CONSTRUCTOR_ELTS (NODE)))
#define CONSTRUCTOR_NO_CLEARING(NODE) \
(CONSTRUCTOR_CHECK (NODE)->base.public_flag)
#define FOR_EACH_CONSTRUCTOR_VALUE(V, IX, VAL) \
for (IX = 0; (IX >= vec_safe_length (V)) \
? false \
: ((VAL = (*(V))[IX].value), \
true); \
(IX)++)
#define FOR_EACH_CONSTRUCTOR_ELT(V, IX, INDEX, VAL) \
for (IX = 0; (IX >= vec_safe_length (V)) \
? false \
: (((void) (VAL = (*V)[IX].value)), \
(INDEX = (*V)[IX].index), \
true); \
(IX)++)
#define CONSTRUCTOR_APPEND_ELT(V, INDEX, VALUE) \
do { \
constructor_elt _ce___ = {INDEX, VALUE}; \
vec_safe_push ((V), _ce___); \
} while (0)
#define CONSTRUCTOR_BITFIELD_P(NODE) \
(DECL_BIT_FIELD (FIELD_DECL_CHECK (NODE)) && DECL_MODE (NODE) != BLKmode)
#define TREE_CLOBBER_P(NODE) \
(TREE_CODE (NODE) == CONSTRUCTOR && TREE_THIS_VOLATILE (NODE))
#define IS_EMPTY_STMT(NODE)	(TREE_CODE (NODE) == NOP_EXPR \
&& VOID_TYPE_P (TREE_TYPE (NODE)) \
&& integer_zerop (TREE_OPERAND (NODE, 0)))
#define TREE_OPERAND_LENGTH(NODE) tree_operand_length (NODE)
#define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)
#define VL_EXP_OPERAND_LENGTH(NODE) \
((int)TREE_INT_CST_LOW (VL_EXP_CHECK (NODE)->exp.operands[0]))
#define MAY_HAVE_DEBUG_MARKER_STMTS debug_nonbind_markers_p
#define MAY_HAVE_DEBUG_BIND_STMTS flag_var_tracking_assignments
#define MAY_HAVE_DEBUG_STMTS					\
(MAY_HAVE_DEBUG_MARKER_STMTS || MAY_HAVE_DEBUG_BIND_STMTS)
#define LOOP_EXPR_BODY(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_EXPR, 0)
#define EXPR_LOCATION(NODE) \
(CAN_HAVE_LOCATION_P ((NODE)) ? (NODE)->exp.locus : UNKNOWN_LOCATION)
#define SET_EXPR_LOCATION(NODE, LOCUS) EXPR_CHECK ((NODE))->exp.locus = (LOCUS)
#define EXPR_HAS_LOCATION(NODE) (LOCATION_LOCUS (EXPR_LOCATION (NODE))	\
!= UNKNOWN_LOCATION)
#define EXPR_LOC_OR_LOC(NODE, LOCUS) (EXPR_HAS_LOCATION (NODE) \
? (NODE)->exp.locus : (LOCUS))
#define EXPR_FILENAME(NODE) LOCATION_FILE (EXPR_CHECK ((NODE))->exp.locus)
#define EXPR_LINENO(NODE) LOCATION_LINE (EXPR_CHECK (NODE)->exp.locus)
#define CAN_HAVE_RANGE_P(NODE) (CAN_HAVE_LOCATION_P (NODE))
#define EXPR_LOCATION_RANGE(NODE) (get_expr_source_range (EXPR_CHECK ((NODE))))
#define EXPR_HAS_RANGE(NODE) \
(CAN_HAVE_RANGE_P (NODE) \
? EXPR_LOCATION_RANGE (NODE).m_start != UNKNOWN_LOCATION \
: false)
#define CAN_HAVE_LOCATION_P(NODE) ((NODE) && EXPR_P (NODE))
static inline source_range
get_expr_source_range (tree expr)
{
location_t loc = EXPR_LOCATION (expr);
return get_range_from_loc (line_table, loc);
}
extern void protected_set_expr_location (tree, location_t);
extern tree maybe_wrap_with_location (tree, location_t);
#define TARGET_EXPR_SLOT(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 0)
#define TARGET_EXPR_INITIAL(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 1)
#define TARGET_EXPR_CLEANUP(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 2)
#define TARGET_EXPR_NO_ELIDE(NODE) (TARGET_EXPR_CHECK (NODE)->base.private_flag)
#define DECL_EXPR_DECL(NODE)    TREE_OPERAND (DECL_EXPR_CHECK (NODE), 0)
#define EXIT_EXPR_COND(NODE)	     TREE_OPERAND (EXIT_EXPR_CHECK (NODE), 0)
#define COMPOUND_LITERAL_EXPR_DECL_EXPR(NODE)		\
TREE_OPERAND (COMPOUND_LITERAL_EXPR_CHECK (NODE), 0)
#define COMPOUND_LITERAL_EXPR_DECL(NODE)			\
DECL_EXPR_DECL (COMPOUND_LITERAL_EXPR_DECL_EXPR (NODE))
#define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_EXPR_CHECK (NODE), 0)
#define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_EXPR_CHECK (NODE), 1)
#define SWITCH_ALL_CASES_P(NODE) (SWITCH_EXPR_CHECK (NODE)->base.private_flag)
#define CASE_LOW(NODE)          	TREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 0)
#define CASE_HIGH(NODE)         	TREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 1)
#define CASE_LABEL(NODE)		TREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 2)
#define CASE_CHAIN(NODE)		TREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 3)
#define TMR_BASE(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 0))
#define TMR_OFFSET(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 1))
#define TMR_INDEX(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 2))
#define TMR_STEP(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 3))
#define TMR_INDEX2(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 4))
#define MR_DEPENDENCE_CLIQUE(NODE) \
(TREE_CHECK2 (NODE, MEM_REF, TARGET_MEM_REF)->base.u.dependence_info.clique)
#define MR_DEPENDENCE_BASE(NODE) \
(TREE_CHECK2 (NODE, MEM_REF, TARGET_MEM_REF)->base.u.dependence_info.base)
#define BIND_EXPR_VARS(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 0))
#define BIND_EXPR_BODY(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 1))
#define BIND_EXPR_BLOCK(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 2))
#define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_EXPR_CHECK (NODE), 0)
#define ASM_STRING(NODE)        TREE_OPERAND (ASM_EXPR_CHECK (NODE), 0)
#define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_EXPR_CHECK (NODE), 1)
#define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_EXPR_CHECK (NODE), 2)
#define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_EXPR_CHECK (NODE), 3)
#define ASM_LABELS(NODE)	TREE_OPERAND (ASM_EXPR_CHECK (NODE), 4)
#define ASM_INPUT_P(NODE) (ASM_EXPR_CHECK (NODE)->base.static_flag)
#define ASM_VOLATILE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.public_flag)
#define ASM_INLINE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.protected_flag)
#define COND_EXPR_COND(NODE)	(TREE_OPERAND (COND_EXPR_CHECK (NODE), 0))
#define COND_EXPR_THEN(NODE)	(TREE_OPERAND (COND_EXPR_CHECK (NODE), 1))
#define COND_EXPR_ELSE(NODE)	(TREE_OPERAND (COND_EXPR_CHECK (NODE), 2))
#define CHREC_LEFT(NODE)          TREE_OPERAND (POLYNOMIAL_CHREC_CHECK (NODE), 0)
#define CHREC_RIGHT(NODE)         TREE_OPERAND (POLYNOMIAL_CHREC_CHECK (NODE), 1)
#define CHREC_VARIABLE(NODE)      POLYNOMIAL_CHREC_CHECK (NODE)->base.u.chrec_var
#define LABEL_EXPR_LABEL(NODE)  TREE_OPERAND (LABEL_EXPR_CHECK (NODE), 0)
#define CATCH_TYPES(NODE)	TREE_OPERAND (CATCH_EXPR_CHECK (NODE), 0)
#define CATCH_BODY(NODE)	TREE_OPERAND (CATCH_EXPR_CHECK (NODE), 1)
#define EH_FILTER_TYPES(NODE)	TREE_OPERAND (EH_FILTER_EXPR_CHECK (NODE), 0)
#define EH_FILTER_FAILURE(NODE)	TREE_OPERAND (EH_FILTER_EXPR_CHECK (NODE), 1)
#define OBJ_TYPE_REF_EXPR(NODE)	  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 0)
#define OBJ_TYPE_REF_OBJECT(NODE) TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 1)
#define OBJ_TYPE_REF_TOKEN(NODE)  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 2)
#define ASSERT_EXPR_VAR(NODE)	TREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 0)
#define ASSERT_EXPR_COND(NODE)	TREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 1)
#define CALL_EXPR_FN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 1)
#define CALL_EXPR_STATIC_CHAIN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 2)
#define CALL_EXPR_ARG(NODE, I) TREE_OPERAND (CALL_EXPR_CHECK (NODE), (I) + 3)
#define call_expr_nargs(NODE) (VL_EXP_OPERAND_LENGTH (NODE) - 3)
#define CALL_EXPR_IFN(NODE) (CALL_EXPR_CHECK (NODE)->base.u.ifn)
#define CALL_EXPR_ARGP(NODE) \
(&(TREE_OPERAND (CALL_EXPR_CHECK (NODE), 0)) + 3)
#define TRANSACTION_EXPR_BODY(NODE) \
TREE_OPERAND (TRANSACTION_EXPR_CHECK (NODE), 0)
#define TRANSACTION_EXPR_OUTER(NODE) \
(TRANSACTION_EXPR_CHECK (NODE)->base.static_flag)
#define TRANSACTION_EXPR_RELAXED(NODE) \
(TRANSACTION_EXPR_CHECK (NODE)->base.public_flag)
#define OMP_BODY(NODE) \
TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_TASKGROUP), 0)
#define OMP_CLAUSES(NODE) \
TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_SINGLE), 1)
#define OMP_STANDALONE_CLAUSES(NODE) \
TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_CACHE, OMP_TARGET_EXIT_DATA), 0)
#define OACC_DATA_BODY(NODE) \
TREE_OPERAND (OACC_DATA_CHECK (NODE), 0)
#define OACC_DATA_CLAUSES(NODE) \
TREE_OPERAND (OACC_DATA_CHECK (NODE), 1)
#define OACC_HOST_DATA_BODY(NODE) \
TREE_OPERAND (OACC_HOST_DATA_CHECK (NODE), 0)
#define OACC_HOST_DATA_CLAUSES(NODE) \
TREE_OPERAND (OACC_HOST_DATA_CHECK (NODE), 1)
#define OACC_CACHE_CLAUSES(NODE) \
TREE_OPERAND (OACC_CACHE_CHECK (NODE), 0)
#define OACC_DECLARE_CLAUSES(NODE) \
TREE_OPERAND (OACC_DECLARE_CHECK (NODE), 0)
#define OACC_ENTER_DATA_CLAUSES(NODE) \
TREE_OPERAND (OACC_ENTER_DATA_CHECK (NODE), 0)
#define OACC_EXIT_DATA_CLAUSES(NODE) \
TREE_OPERAND (OACC_EXIT_DATA_CHECK (NODE), 0)
#define OACC_UPDATE_CLAUSES(NODE) \
TREE_OPERAND (OACC_UPDATE_CHECK (NODE), 0)
#define OMP_PARALLEL_BODY(NODE)    TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 0)
#define OMP_PARALLEL_CLAUSES(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 1)
#define OMP_TASK_BODY(NODE)	   TREE_OPERAND (OMP_TASK_CHECK (NODE), 0)
#define OMP_TASK_CLAUSES(NODE)	   TREE_OPERAND (OMP_TASK_CHECK (NODE), 1)
#define OMP_TASKREG_CHECK(NODE)	  TREE_RANGE_CHECK (NODE, OMP_PARALLEL, OMP_TASK)
#define OMP_TASKREG_BODY(NODE)    TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 0)
#define OMP_TASKREG_CLAUSES(NODE) TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 1)
#define OMP_LOOP_CHECK(NODE) TREE_RANGE_CHECK (NODE, OMP_FOR, OACC_LOOP)
#define OMP_FOR_BODY(NODE)	   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 0)
#define OMP_FOR_CLAUSES(NODE)	   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 1)
#define OMP_FOR_INIT(NODE)	   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 2)
#define OMP_FOR_COND(NODE)	   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 3)
#define OMP_FOR_INCR(NODE)	   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 4)
#define OMP_FOR_PRE_BODY(NODE)	   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 5)
#define OMP_FOR_ORIG_DECLS(NODE)   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 6)
#define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)
#define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)
#define OMP_SECTION_BODY(NODE)	   TREE_OPERAND (OMP_SECTION_CHECK (NODE), 0)
#define OMP_SINGLE_BODY(NODE)	   TREE_OPERAND (OMP_SINGLE_CHECK (NODE), 0)
#define OMP_SINGLE_CLAUSES(NODE)   TREE_OPERAND (OMP_SINGLE_CHECK (NODE), 1)
#define OMP_MASTER_BODY(NODE)	   TREE_OPERAND (OMP_MASTER_CHECK (NODE), 0)
#define OMP_TASKGROUP_BODY(NODE)   TREE_OPERAND (OMP_TASKGROUP_CHECK (NODE), 0)
#define OMP_ORDERED_BODY(NODE)	   TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 0)
#define OMP_ORDERED_CLAUSES(NODE)  TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 1)
#define OMP_CRITICAL_BODY(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 0)
#define OMP_CRITICAL_CLAUSES(NODE) TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 1)
#define OMP_CRITICAL_NAME(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 2)
#define OMP_TEAMS_BODY(NODE)	   TREE_OPERAND (OMP_TEAMS_CHECK (NODE), 0)
#define OMP_TEAMS_CLAUSES(NODE)	   TREE_OPERAND (OMP_TEAMS_CHECK (NODE), 1)
#define OMP_TARGET_DATA_BODY(NODE) \
TREE_OPERAND (OMP_TARGET_DATA_CHECK (NODE), 0)
#define OMP_TARGET_DATA_CLAUSES(NODE)\
TREE_OPERAND (OMP_TARGET_DATA_CHECK (NODE), 1)
#define OMP_TARGET_BODY(NODE)	   TREE_OPERAND (OMP_TARGET_CHECK (NODE), 0)
#define OMP_TARGET_CLAUSES(NODE)   TREE_OPERAND (OMP_TARGET_CHECK (NODE), 1)
#define OMP_TARGET_UPDATE_CLAUSES(NODE)\
TREE_OPERAND (OMP_TARGET_UPDATE_CHECK (NODE), 0)
#define OMP_TARGET_ENTER_DATA_CLAUSES(NODE)\
TREE_OPERAND (OMP_TARGET_ENTER_DATA_CHECK (NODE), 0)
#define OMP_TARGET_EXIT_DATA_CLAUSES(NODE)\
TREE_OPERAND (OMP_TARGET_EXIT_DATA_CHECK (NODE), 0)
#define OMP_CLAUSE_SIZE(NODE)						\
OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),	\
OMP_CLAUSE_FROM,		\
OMP_CLAUSE__CACHE_), 1)
#define OMP_CLAUSE_CHAIN(NODE)     TREE_CHAIN (OMP_CLAUSE_CHECK (NODE))
#define OMP_CLAUSE_DECL(NODE)      					\
OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),	\
OMP_CLAUSE_PRIVATE,	\
OMP_CLAUSE__LOOPTEMP_), 0)
#define OMP_CLAUSE_HAS_LOCATION(NODE) \
(LOCATION_LOCUS ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus)		\
!= UNKNOWN_LOCATION)
#define OMP_CLAUSE_LOCATION(NODE)  (OMP_CLAUSE_CHECK (NODE))->omp_clause.locus
#define OMP_SECTION_LAST(NODE) \
(OMP_SECTION_CHECK (NODE)->base.private_flag)
#define OMP_PARALLEL_COMBINED(NODE) \
(OMP_PARALLEL_CHECK (NODE)->base.private_flag)
#define OMP_TEAMS_COMBINED(NODE) \
(OMP_TEAMS_CHECK (NODE)->base.private_flag)
#define OMP_TARGET_COMBINED(NODE) \
(OMP_TARGET_CHECK (NODE)->base.private_flag)
#define OMP_ATOMIC_SEQ_CST(NODE) \
(TREE_RANGE_CHECK (NODE, OMP_ATOMIC, \
OMP_ATOMIC_CAPTURE_NEW)->base.private_flag)
#define OMP_CLAUSE_PRIVATE_DEBUG(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE)->base.public_flag)
#define OMP_CLAUSE_PRIVATE_OUTER_REF(NODE) \
TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE))
#define OMP_CLAUSE_PRIVATE_TASKLOOP_IV(NODE) \
TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE))
#define OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FIRSTPRIVATE)->base.public_flag)
#define OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE)->base.public_flag)
#define OMP_CLAUSE_LASTPRIVATE_STMT(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE,			\
OMP_CLAUSE_LASTPRIVATE),\
1)
#define OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ(NODE) \
(OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init
#define OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV(NODE) \
TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE))
#define OMP_CLAUSE_SHARED_FIRSTPRIVATE(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SHARED)->base.public_flag)
#define OMP_CLAUSE_SHARED_READONLY(NODE) \
TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SHARED))
#define OMP_CLAUSE_IF_MODIFIER(NODE)	\
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_IF)->omp_clause.subcode.if_modifier)
#define OMP_CLAUSE_FINAL_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FINAL), 0)
#define OMP_CLAUSE_IF_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_IF), 0)
#define OMP_CLAUSE_NUM_THREADS_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_THREADS),0)
#define OMP_CLAUSE_SCHEDULE_CHUNK_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE), 0)
#define OMP_CLAUSE_NUM_TASKS_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_TASKS), 0)
#define OMP_CLAUSE_HINT_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_HINT), 0)
#define OMP_CLAUSE_GRAINSIZE_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GRAINSIZE),0)
#define OMP_CLAUSE_PRIORITY_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIORITY),0)
#define OMP_CLAUSE_EXPR(NODE, CLAUSE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, CLAUSE), 0)
#define OMP_CLAUSE_GANG_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GANG), 0)
#define OMP_CLAUSE_GANG_STATIC_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GANG), 1)
#define OMP_CLAUSE_ASYNC_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ASYNC), 0)
#define OMP_CLAUSE_WAIT_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_WAIT), 0)
#define OMP_CLAUSE_VECTOR_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_VECTOR), 0)
#define OMP_CLAUSE_WORKER_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_WORKER), 0)
#define OMP_CLAUSE_NUM_GANGS_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_GANGS), 0)
#define OMP_CLAUSE_NUM_WORKERS_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_WORKERS), 0)
#define OMP_CLAUSE_VECTOR_LENGTH_EXPR(NODE) \
OMP_CLAUSE_OPERAND ( \
OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_VECTOR_LENGTH), 0)
#define OMP_CLAUSE_DEPEND_KIND(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEPEND)->omp_clause.subcode.depend_kind)
#define OMP_CLAUSE_DEPEND_SINK_NEGATIVE(NODE) \
TREE_PUBLIC (TREE_LIST_CHECK (NODE))
#define OMP_CLAUSE_MAP_KIND(NODE) \
((enum gomp_map_kind) OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind)
#define OMP_CLAUSE_SET_MAP_KIND(NODE, MAP_KIND) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind \
= (unsigned int) (MAP_KIND))
#define OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->base.public_flag)
#define OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION(NODE) \
TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP))
#define OMP_CLAUSE_MAP_IN_REDUCTION(NODE) \
TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP))
#define OMP_CLAUSE_PROC_BIND_KIND(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PROC_BIND)->omp_clause.subcode.proc_bind_kind)
#define OMP_CLAUSE_COLLAPSE_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 0)
#define OMP_CLAUSE_COLLAPSE_ITERVAR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 1)
#define OMP_CLAUSE_COLLAPSE_COUNT(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 2)
#define OMP_CLAUSE_ORDERED_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDERED), 0)
#define OMP_CLAUSE_REDUCTION_CODE(NODE)	\
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)->omp_clause.subcode.reduction_code)
#define OMP_CLAUSE_REDUCTION_INIT(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 1)
#define OMP_CLAUSE_REDUCTION_MERGE(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 2)
#define OMP_CLAUSE_REDUCTION_GIMPLE_INIT(NODE) \
(OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init
#define OMP_CLAUSE_REDUCTION_GIMPLE_MERGE(NODE) \
(OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_merge
#define OMP_CLAUSE_REDUCTION_PLACEHOLDER(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 3)
#define OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 4)
#define OMP_CLAUSE_REDUCTION_OMP_ORIG_REF(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)->base.public_flag)
#define OMP_CLAUSE_LINEAR_NO_COPYIN(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)->base.public_flag)
#define OMP_CLAUSE_LINEAR_NO_COPYOUT(NODE) \
TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))
#define OMP_CLAUSE_LINEAR_VARIABLE_STRIDE(NODE) \
TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))
#define OMP_CLAUSE_LINEAR_ARRAY(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)->base.deprecated_flag)
#define OMP_CLAUSE_LINEAR_STEP(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 1)
#define OMP_CLAUSE_LINEAR_STMT(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 2)
#define OMP_CLAUSE_LINEAR_GIMPLE_SEQ(NODE) \
(OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init
#define OMP_CLAUSE_LINEAR_KIND(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)->omp_clause.subcode.linear_kind)
#define OMP_CLAUSE_ALIGNED_ALIGNMENT(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALIGNED), 1)
#define OMP_CLAUSE_NUM_TEAMS_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_TEAMS), 0)
#define OMP_CLAUSE_THREAD_LIMIT_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, \
OMP_CLAUSE_THREAD_LIMIT), 0)
#define OMP_CLAUSE_DEVICE_ID(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEVICE), 0)
#define OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, \
OMP_CLAUSE_DIST_SCHEDULE), 0)
#define OMP_CLAUSE_SAFELEN_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SAFELEN), 0)
#define OMP_CLAUSE_SIMDLEN_EXPR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SIMDLEN), 0)
#define OMP_CLAUSE__SIMDUID__DECL(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__SIMDUID_), 0)
#define OMP_CLAUSE_SCHEDULE_KIND(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE)->omp_clause.subcode.schedule_kind)
#define OMP_CLAUSE_SCHEDULE_SIMD(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE)->base.public_flag)
#define OMP_CLAUSE_DEFAULT_KIND(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEFAULT)->omp_clause.subcode.default_kind)
#define OMP_CLAUSE_TILE_LIST(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 0)
#define OMP_CLAUSE_TILE_ITERVAR(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 1)
#define OMP_CLAUSE_TILE_COUNT(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 2)
#define OMP_CLAUSE__GRIDDIM__DIMENSION(NODE) \
(OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_)\
->omp_clause.subcode.dimension)
#define OMP_CLAUSE__GRIDDIM__SIZE(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_), 0)
#define OMP_CLAUSE__GRIDDIM__GROUP(NODE) \
OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_), 1)
#define SSA_NAME_IS_VIRTUAL_OPERAND(NODE) \
SSA_NAME_CHECK (NODE)->base.public_flag
#define SSA_NAME_IDENTIFIER(NODE)				\
(SSA_NAME_CHECK (NODE)->ssa_name.var != NULL_TREE		\
? (TREE_CODE ((NODE)->ssa_name.var) == IDENTIFIER_NODE	\
? (NODE)->ssa_name.var					\
: DECL_NAME ((NODE)->ssa_name.var))			\
: NULL_TREE)
#define SSA_NAME_VAR(NODE)					\
(SSA_NAME_CHECK (NODE)->ssa_name.var == NULL_TREE		\
|| TREE_CODE ((NODE)->ssa_name.var) == IDENTIFIER_NODE	\
? NULL_TREE : (NODE)->ssa_name.var)
#define SET_SSA_NAME_VAR_OR_IDENTIFIER(NODE,VAR) \
do \
{ \
tree var_ = (VAR); \
SSA_NAME_CHECK (NODE)->ssa_name.var = var_; \
SSA_NAME_IS_VIRTUAL_OPERAND (NODE) \
= (var_ \
&& TREE_CODE (var_) == VAR_DECL \
&& VAR_DECL_IS_VIRTUAL_OPERAND (var_)); \
} \
while (0)
#define SSA_NAME_DEF_STMT(NODE)	SSA_NAME_CHECK (NODE)->ssa_name.def_stmt
#define SSA_NAME_VERSION(NODE)	SSA_NAME_CHECK (NODE)->base.u.version
#define SSA_NAME_OCCURS_IN_ABNORMAL_PHI(NODE) \
SSA_NAME_CHECK (NODE)->base.asm_written_flag
#define SSA_NAME_IN_FREE_LIST(NODE) \
SSA_NAME_CHECK (NODE)->base.nothrow_flag
#define SSA_NAME_IS_DEFAULT_DEF(NODE) \
SSA_NAME_CHECK (NODE)->base.default_def_flag
#define SSA_NAME_PTR_INFO(N) \
SSA_NAME_CHECK (N)->ssa_name.info.ptr_info
#define SSA_NAME_ANTI_RANGE_P(N) \
SSA_NAME_CHECK (N)->base.static_flag
#define SSA_NAME_RANGE_TYPE(N) \
(SSA_NAME_ANTI_RANGE_P (N) ? VR_ANTI_RANGE : VR_RANGE)
#define SSA_NAME_RANGE_INFO(N) \
SSA_NAME_CHECK (N)->ssa_name.info.range_info
#define SSA_NAME_IMM_USE_NODE(NODE) SSA_NAME_CHECK (NODE)->ssa_name.imm_uses
#define OMP_CLAUSE_CODE(NODE)					\
(OMP_CLAUSE_CHECK (NODE))->omp_clause.code
#define OMP_CLAUSE_SET_CODE(NODE, CODE)				\
((OMP_CLAUSE_CHECK (NODE))->omp_clause.code = (CODE))
#define OMP_CLAUSE_OPERAND(NODE, I)				\
OMP_CLAUSE_ELT_CHECK (NODE, I)
#define BLOCK_VARS(NODE) (BLOCK_CHECK (NODE)->block.vars)
#define BLOCK_NONLOCALIZED_VARS(NODE) \
(BLOCK_CHECK (NODE)->block.nonlocalized_vars)
#define BLOCK_NUM_NONLOCALIZED_VARS(NODE) \
vec_safe_length (BLOCK_NONLOCALIZED_VARS (NODE))
#define BLOCK_NONLOCALIZED_VAR(NODE,N) (*BLOCK_NONLOCALIZED_VARS (NODE))[N]
#define BLOCK_SUBBLOCKS(NODE) (BLOCK_CHECK (NODE)->block.subblocks)
#define BLOCK_SUPERCONTEXT(NODE) (BLOCK_CHECK (NODE)->block.supercontext)
#define BLOCK_CHAIN(NODE) (BLOCK_CHECK (NODE)->block.chain)
#define BLOCK_ABSTRACT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.abstract_origin)
#define BLOCK_ABSTRACT(NODE) (BLOCK_CHECK (NODE)->block.abstract_flag)
#define BLOCK_DIE(NODE) (BLOCK_CHECK (NODE)->block.die)
#define BLOCK_SAME_RANGE(NODE) (BLOCK_CHECK (NODE)->base.u.bits.nameless_flag)
#define BLOCK_IN_COLD_SECTION_P(NODE) \
(BLOCK_CHECK (NODE)->base.u.bits.atomic_flag)
#define BLOCK_NUMBER(NODE) (BLOCK_CHECK (NODE)->block.block_num)
#define BLOCK_FRAGMENT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_origin)
#define BLOCK_FRAGMENT_CHAIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_chain)
#define BLOCK_SOURCE_LOCATION(NODE) (BLOCK_CHECK (NODE)->block.locus)
#define BLOCK_SOURCE_END_LOCATION(NODE) (BLOCK_CHECK (NODE)->block.end_locus)
#define TYPE_UID(NODE) (TYPE_CHECK (NODE)->type_common.uid)
#define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)->type_common.size)
#define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type_common.size_unit)
#define TYPE_POINTER_TO(NODE) (TYPE_CHECK (NODE)->type_common.pointer_to)
#define TYPE_REFERENCE_TO(NODE) (TYPE_CHECK (NODE)->type_common.reference_to)
#define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)->type_common.precision)
#define TYPE_NAME(NODE) (TYPE_CHECK (NODE)->type_common.name)
#define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)->type_common.next_variant)
#define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type_common.main_variant)
#define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type_common.context)
#define TYPE_MODE_RAW(NODE) (TYPE_CHECK (NODE)->type_common.mode)
#define TYPE_MODE(NODE) \
(VECTOR_TYPE_P (TYPE_CHECK (NODE)) \
? vector_type_mode (NODE) : (NODE)->type_common.mode)
#define SCALAR_TYPE_MODE(NODE) \
(as_a <scalar_mode> (TYPE_CHECK (NODE)->type_common.mode))
#define SCALAR_INT_TYPE_MODE(NODE) \
(as_a <scalar_int_mode> (TYPE_CHECK (NODE)->type_common.mode))
#define SCALAR_FLOAT_TYPE_MODE(NODE) \
(as_a <scalar_float_mode> (TYPE_CHECK (NODE)->type_common.mode))
#define SET_TYPE_MODE(NODE, MODE) \
(TYPE_CHECK (NODE)->type_common.mode = (MODE))
extern machine_mode element_mode (const_tree);
extern machine_mode vector_type_mode (const_tree);
#define TYPE_CANONICAL(NODE) (TYPE_CHECK (NODE)->type_common.canonical)
#define TYPE_STRUCTURAL_EQUALITY_P(NODE) (TYPE_CANONICAL (NODE) == NULL_TREE)
#define SET_TYPE_STRUCTURAL_EQUALITY(NODE) (TYPE_CANONICAL (NODE) = NULL_TREE)
#define TYPE_IBIT(NODE) (GET_MODE_IBIT (TYPE_MODE (NODE)))
#define TYPE_FBIT(NODE) (GET_MODE_FBIT (TYPE_MODE (NODE)))
#define TYPE_ALIAS_SET(NODE) (TYPE_CHECK (NODE)->type_common.alias_set)
#define TYPE_ALIAS_SET_KNOWN_P(NODE) \
(TYPE_CHECK (NODE)->type_common.alias_set != -1)
#define TYPE_ATTRIBUTES(NODE) (TYPE_CHECK (NODE)->type_common.attributes)
#define TYPE_ALIGN(NODE) \
(TYPE_CHECK (NODE)->type_common.align \
? ((unsigned)1) << ((NODE)->type_common.align - 1) : 0)
#define SET_TYPE_ALIGN(NODE, X) \
(TYPE_CHECK (NODE)->type_common.align = ffs_hwi (X))
#define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)->base.u.bits.user_align)
#define TYPE_ALIGN_UNIT(NODE) (TYPE_ALIGN (NODE) / BITS_PER_UNIT)
#define TYPE_WARN_IF_NOT_ALIGN(NODE) \
(TYPE_CHECK (NODE)->type_common.warn_if_not_align \
? ((unsigned)1) << ((NODE)->type_common.warn_if_not_align - 1) : 0)
#define SET_TYPE_WARN_IF_NOT_ALIGN(NODE, X) \
(TYPE_CHECK (NODE)->type_common.warn_if_not_align = ffs_hwi (X))
#define TYPE_STUB_DECL(NODE) (TREE_CHAIN (TYPE_CHECK (NODE)))
#define TYPE_NO_FORCE_BLK(NODE) \
(TYPE_CHECK (NODE)->type_common.no_force_blk_flag)
#define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->base.volatile_flag)
#define TYPE_ATOMIC(NODE) (TYPE_CHECK (NODE)->base.u.bits.atomic_flag)
#define TYPE_READONLY(NODE) (TYPE_CHECK (NODE)->base.readonly_flag)
#define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type_common.restrict_flag)
#define TYPE_NAMELESS(NODE) (TYPE_CHECK (NODE)->base.u.bits.nameless_flag)
#define TYPE_ADDR_SPACE(NODE) (TYPE_CHECK (NODE)->base.u.bits.address_space)
#define ENCODE_QUAL_ADDR_SPACE(NUM) ((NUM & 0xFF) << 8)
#define DECODE_QUAL_ADDR_SPACE(X) (((X) >> 8) & 0xFF)
#define CLEAR_QUAL_ADDR_SPACE(X) ((X) & ~0xFF00)
#define KEEP_QUAL_ADDR_SPACE(X) ((X) & 0xFF00)
#define TYPE_QUALS(NODE)					\
((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)		\
| (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)		\
| (TYPE_ATOMIC (NODE) * TYPE_QUAL_ATOMIC)		\
| (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)		\
| (ENCODE_QUAL_ADDR_SPACE (TYPE_ADDR_SPACE (NODE)))))
#define TYPE_QUALS_NO_ADDR_SPACE(NODE)				\
((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)		\
| (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)		\
| (TYPE_ATOMIC (NODE) * TYPE_QUAL_ATOMIC)		\
| (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)))
#define TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC(NODE)		\
((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)		\
| (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)		\
| (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)))
#define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_0)
#define TYPE_LANG_FLAG_1(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_1)
#define TYPE_LANG_FLAG_2(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_2)
#define TYPE_LANG_FLAG_3(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_3)
#define TYPE_LANG_FLAG_4(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_4)
#define TYPE_LANG_FLAG_5(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_5)
#define TYPE_LANG_FLAG_6(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_6)
#define TYPE_LANG_FLAG_7(NODE) (TYPE_CHECK (NODE)->type_common.lang_flag_7)
#define TREE_VISITED(NODE) ((NODE)->base.visited)
#define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type_common.string_flag)
#define TYPE_VECTOR_OPAQUE(NODE) \
(VECTOR_TYPE_CHECK (NODE)->base.default_def_flag)
#define TYPE_NEEDS_CONSTRUCTING(NODE) \
(TYPE_CHECK (NODE)->type_common.needs_constructing_flag)
#define TYPE_TRANSPARENT_AGGR(NODE) \
(RECORD_OR_UNION_CHECK (NODE)->type_common.transparent_aggr_flag)
#define TYPE_NONALIASED_COMPONENT(NODE) \
(ARRAY_TYPE_CHECK (NODE)->type_common.transparent_aggr_flag)
#define TYPE_TYPELESS_STORAGE(NODE) \
(TREE_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, \
ARRAY_TYPE)->type_common.typeless_storage)
#define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)->base.u.bits.packed_flag)
#define TYPE_CONTAINS_PLACEHOLDER_INTERNAL(NODE) \
(TYPE_CHECK (NODE)->type_common.contains_placeholder_bits)
#define TYPE_FINAL_P(NODE) \
(RECORD_OR_UNION_CHECK (NODE)->base.default_def_flag)
#define TYPE_SYMTAB_ADDRESS(NODE) \
(TYPE_CHECK (NODE)->type_common.symtab.address)
#define TYPE_SYMTAB_DIE(NODE) \
(TYPE_CHECK (NODE)->type_common.symtab.die)
#define TYPE_SYMTAB_IS_ADDRESS (0)
#define TYPE_SYMTAB_IS_DIE (1)
#define TYPE_LANG_SPECIFIC(NODE) \
(TYPE_CHECK (NODE)->type_with_lang_specific.lang_specific)
#define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type_non_common.values)
#define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type_non_common.values)
#define TYPE_FIELDS(NODE)				\
(RECORD_OR_UNION_CHECK (NODE)->type_non_common.values)
#define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK (NODE)->type_non_common.values)
#define TYPE_ARG_TYPES(NODE)				\
(FUNC_OR_METHOD_CHECK (NODE)->type_non_common.values)
#define TYPE_VALUES_RAW(NODE) (TYPE_CHECK (NODE)->type_non_common.values)
#define TYPE_MIN_VALUE(NODE)				\
(NUMERICAL_TYPE_CHECK (NODE)->type_non_common.minval)
#define TYPE_NEXT_PTR_TO(NODE)				\
(POINTER_TYPE_CHECK (NODE)->type_non_common.minval)
#define TYPE_NEXT_REF_TO(NODE)				\
(REFERENCE_TYPE_CHECK (NODE)->type_non_common.minval)
#define TYPE_VFIELD(NODE)				\
(RECORD_OR_UNION_CHECK (NODE)->type_non_common.minval)
#define TYPE_MIN_VALUE_RAW(NODE) (TYPE_CHECK (NODE)->type_non_common.minval)
#define TYPE_MAX_VALUE(NODE) \
(NUMERICAL_TYPE_CHECK (NODE)->type_non_common.maxval)
#define TYPE_METHOD_BASETYPE(NODE)			\
(FUNC_OR_METHOD_CHECK (NODE)->type_non_common.maxval)
#define TYPE_OFFSET_BASETYPE(NODE)			\
(OFFSET_TYPE_CHECK (NODE)->type_non_common.maxval)
#define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) \
(ARRAY_TYPE_CHECK (ARRAY_TYPE)->type_non_common.maxval)
#define TYPE_MAX_VALUE_RAW(NODE) (TYPE_CHECK (NODE)->type_non_common.maxval)
#define TYPE_BINFO(NODE) (RECORD_OR_UNION_CHECK (NODE)->type_non_common.maxval)
#define TYPE_LANG_SLOT_1(NODE) \
(TYPE_CHECK (NODE)->type_non_common.lang_1)
#define BINFO_VIRTUAL_P(NODE) (TREE_BINFO_CHECK (NODE)->base.static_flag)
#define BINFO_FLAG_0(NODE) TREE_LANG_FLAG_0 (TREE_BINFO_CHECK (NODE))
#define BINFO_FLAG_1(NODE) TREE_LANG_FLAG_1 (TREE_BINFO_CHECK (NODE))
#define BINFO_FLAG_2(NODE) TREE_LANG_FLAG_2 (TREE_BINFO_CHECK (NODE))
#define BINFO_FLAG_3(NODE) TREE_LANG_FLAG_3 (TREE_BINFO_CHECK (NODE))
#define BINFO_FLAG_4(NODE) TREE_LANG_FLAG_4 (TREE_BINFO_CHECK (NODE))
#define BINFO_FLAG_5(NODE) TREE_LANG_FLAG_5 (TREE_BINFO_CHECK (NODE))
#define BINFO_FLAG_6(NODE) TREE_LANG_FLAG_6 (TREE_BINFO_CHECK (NODE))
#define BINFO_TYPE(NODE) TREE_TYPE (TREE_BINFO_CHECK (NODE))
#define BINFO_OFFSET(NODE) (TREE_BINFO_CHECK (NODE)->binfo.offset)
#define BINFO_OFFSET_ZEROP(NODE) (integer_zerop (BINFO_OFFSET (NODE)))
#define BINFO_VTABLE(NODE) (TREE_BINFO_CHECK (NODE)->binfo.vtable)
#define BINFO_VIRTUALS(NODE) (TREE_BINFO_CHECK (NODE)->binfo.virtuals)
#define BINFO_BASE_BINFOS(NODE) (&TREE_BINFO_CHECK (NODE)->binfo.base_binfos)
#define BINFO_N_BASE_BINFOS(NODE) (BINFO_BASE_BINFOS (NODE)->length ())
#define BINFO_BASE_BINFO(NODE,N) \
((*BINFO_BASE_BINFOS (NODE))[(N)])
#define BINFO_BASE_ITERATE(NODE,N,B) \
(BINFO_BASE_BINFOS (NODE)->iterate ((N), &(B)))
#define BINFO_BASE_APPEND(NODE,T) \
(BINFO_BASE_BINFOS (NODE)->quick_push ((T)))
#define BINFO_VPTR_FIELD(NODE) (TREE_BINFO_CHECK (NODE)->binfo.vptr_field)
#define BINFO_BASE_ACCESSES(NODE) \
(TREE_BINFO_CHECK (NODE)->binfo.base_accesses)
#define BINFO_BASE_ACCESS(NODE,N) \
(*BINFO_BASE_ACCESSES (NODE))[(N)]
#define BINFO_BASE_ACCESS_APPEND(NODE,T) \
BINFO_BASE_ACCESSES (NODE)->quick_push ((T))
#define BINFO_SUBVTT_INDEX(NODE) (TREE_BINFO_CHECK (NODE)->binfo.vtt_subvtt)
#define BINFO_VPTR_INDEX(NODE) (TREE_BINFO_CHECK (NODE)->binfo.vtt_vptr)
#define BINFO_INHERITANCE_CHAIN(NODE) \
(TREE_BINFO_CHECK (NODE)->binfo.inheritance)
#define SSA_VAR_P(DECL)							\
(TREE_CODE (DECL) == VAR_DECL					\
|| TREE_CODE (DECL) == PARM_DECL				\
|| TREE_CODE (DECL) == RESULT_DECL				\
|| TREE_CODE (DECL) == SSA_NAME)
#define DECL_CHAIN(NODE) (TREE_CHAIN (DECL_MINIMAL_CHECK (NODE)))
#define DECL_NAME(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.name)
#define TYPE_IDENTIFIER(NODE) \
(TYPE_NAME (NODE) && DECL_P (TYPE_NAME (NODE)) \
? DECL_NAME (TYPE_NAME (NODE)) : TYPE_NAME (NODE))
#define DECL_UID(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.uid)
#define DEBUG_TEMP_UID(NODE) (-DECL_UID (TREE_CHECK ((NODE), DEBUG_EXPR_DECL)))
#define DECL_PT_UID(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.pt_uid == -1u \
? (NODE)->decl_minimal.uid : (NODE)->decl_common.pt_uid)
#define SET_DECL_PT_UID(NODE, UID) \
(DECL_COMMON_CHECK (NODE)->decl_common.pt_uid = (UID))
#define DECL_PT_UID_SET_P(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.pt_uid != -1u)
#define DECL_SOURCE_LOCATION(NODE) \
(DECL_MINIMAL_CHECK (NODE)->decl_minimal.locus)
#define DECL_SOURCE_FILE(NODE) LOCATION_FILE (DECL_SOURCE_LOCATION (NODE))
#define DECL_SOURCE_LINE(NODE) LOCATION_LINE (DECL_SOURCE_LOCATION (NODE))
#define DECL_SOURCE_COLUMN(NODE) LOCATION_COLUMN (DECL_SOURCE_LOCATION (NODE))
#define DECL_IS_BUILTIN(DECL) \
(LOCATION_LOCUS (DECL_SOURCE_LOCATION (DECL)) <= BUILTINS_LOCATION)
#define DECL_LOCATION_RANGE(NODE) \
(get_decl_source_range (DECL_MINIMAL_CHECK (NODE)))
#define DECL_CONTEXT(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.context)
#define DECL_FIELD_CONTEXT(NODE) \
(FIELD_DECL_CHECK (NODE)->decl_minimal.context)
#define DECL_NAMELESS(NODE) (DECL_MINIMAL_CHECK (NODE)->base.u.bits.nameless_flag)
#define DECL_ABSTRACT_ORIGIN(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.abstract_origin)
#define DECL_ORIGIN(NODE) \
(DECL_ABSTRACT_ORIGIN (NODE) ? DECL_ABSTRACT_ORIGIN (NODE) : (NODE))
#define DECL_FROM_INLINE(NODE) \
(DECL_ABSTRACT_ORIGIN (NODE) != NULL_TREE \
&& DECL_ABSTRACT_ORIGIN (NODE) != (NODE))
#define DECL_ATTRIBUTES(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.attributes)
#define DECL_INITIAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.initial)
#define DECL_SIZE(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.size)
#define DECL_SIZE_UNIT(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.size_unit)
#define DECL_ALIGN(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.align \
? ((unsigned)1) << ((NODE)->decl_common.align - 1) : 0)
#define SET_DECL_ALIGN(NODE, X) \
(DECL_COMMON_CHECK (NODE)->decl_common.align = ffs_hwi (X))
#define DECL_WARN_IF_NOT_ALIGN(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.warn_if_not_align \
? ((unsigned)1) << ((NODE)->decl_common.warn_if_not_align - 1) : 0)
#define SET_DECL_WARN_IF_NOT_ALIGN(NODE, X) \
(DECL_COMMON_CHECK (NODE)->decl_common.warn_if_not_align = ffs_hwi (X))
#define DECL_ALIGN_UNIT(NODE) (DECL_ALIGN (NODE) / BITS_PER_UNIT)
#define DECL_USER_ALIGN(NODE) \
(DECL_COMMON_CHECK (NODE)->base.u.bits.user_align)
#define DECL_MODE(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.mode)
#define SET_DECL_MODE(NODE, MODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.mode = (MODE))
#define DECL_FUNCTION_CODE(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.function_code)
#define ALLOCA_FUNCTION_CODE_P(FCODE)				\
((FCODE) == BUILT_IN_ALLOCA					\
|| (FCODE) == BUILT_IN_ALLOCA_WITH_ALIGN			\
|| (FCODE) == BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX)
#define CASE_BUILT_IN_ALLOCA			\
case BUILT_IN_ALLOCA:				\
case BUILT_IN_ALLOCA_WITH_ALIGN:		\
case BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX
#define DECL_FUNCTION_PERSONALITY(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.personality)
#define DECL_IGNORED_P(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.ignored_flag)
#define DECL_ABSTRACT_P(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.abstract_flag)
#define DECL_LANG_SPECIFIC(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_specific)
#define DECL_EXTERNAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.decl_flag_1)
#define DECL_NONLOCAL(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.nonlocal_flag)
#define DECL_VIRTUAL_P(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.virtual_flag)
#define DECL_ARTIFICIAL(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.artificial_flag)
#define DECL_LANG_FLAG_0(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_0)
#define DECL_LANG_FLAG_1(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_1)
#define DECL_LANG_FLAG_2(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_2)
#define DECL_LANG_FLAG_3(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_3)
#define DECL_LANG_FLAG_4(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_4)
#define DECL_LANG_FLAG_5(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_5)
#define DECL_LANG_FLAG_6(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_6)
#define DECL_LANG_FLAG_7(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_7)
#define DECL_LANG_FLAG_8(NODE) \
(DECL_COMMON_CHECK (NODE)->decl_common.lang_flag_8)
#define SCOPE_FILE_SCOPE_P(EXP)	\
(! (EXP) || TREE_CODE (EXP) == TRANSLATION_UNIT_DECL)
#define DECL_FILE_SCOPE_P(EXP) SCOPE_FILE_SCOPE_P (DECL_CONTEXT (EXP))
#define TYPE_FILE_SCOPE_P(EXP) SCOPE_FILE_SCOPE_P (TYPE_CONTEXT (EXP))
#define DECL_PRESERVE_P(DECL) \
DECL_COMMON_CHECK (DECL)->decl_common.preserve_flag
#define DECL_GIMPLE_REG_P(DECL) \
DECL_COMMON_CHECK (DECL)->decl_common.gimple_reg_flag
extern tree decl_value_expr_lookup (tree);
extern void decl_value_expr_insert (tree, tree);
#define DECL_HAS_VALUE_EXPR_P(NODE) \
(TREE_CHECK3 (NODE, VAR_DECL, PARM_DECL, RESULT_DECL) \
->decl_common.decl_flag_2)
#define DECL_VALUE_EXPR(NODE) \
(decl_value_expr_lookup (DECL_WRTL_CHECK (NODE)))
#define SET_DECL_VALUE_EXPR(NODE, VAL) \
(decl_value_expr_insert (DECL_WRTL_CHECK (NODE), VAL))
#define DECL_RTL(NODE)					\
(DECL_WRTL_CHECK (NODE)->decl_with_rtl.rtl		\
? (NODE)->decl_with_rtl.rtl					\
: (make_decl_rtl (NODE), (NODE)->decl_with_rtl.rtl))
#define SET_DECL_RTL(NODE, RTL) set_decl_rtl (NODE, RTL)
#define HAS_RTL_P(NODE) (CODE_CONTAINS_STRUCT (TREE_CODE (NODE), TS_DECL_WRTL))
#define DECL_RTL_SET_P(NODE) \
(HAS_RTL_P (NODE) && DECL_WRTL_CHECK (NODE)->decl_with_rtl.rtl != NULL)
#define COPY_DECL_RTL(SRC_DECL, DST_DECL) \
(DECL_WRTL_CHECK (DST_DECL)->decl_with_rtl.rtl \
= DECL_WRTL_CHECK (SRC_DECL)->decl_with_rtl.rtl)
#define DECL_RTL_IF_SET(NODE) (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)
#if (GCC_VERSION >= 2007)
#define DECL_RTL_KNOWN_SET(decl) __extension__				\
({  tree const __d = (decl);						\
gcc_checking_assert (DECL_RTL_SET_P (__d));				\
\
&*DECL_RTL_IF_SET (__d); })
#else
#define DECL_RTL_KNOWN_SET(decl) (&*DECL_RTL_IF_SET (decl))
#endif
#define DECL_REGISTER(NODE) (DECL_WRTL_CHECK (NODE)->decl_common.decl_flag_0)
#define DECL_FIELD_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.offset)
#define DECL_FIELD_BIT_OFFSET(NODE) \
(FIELD_DECL_CHECK (NODE)->field_decl.bit_offset)
#define DECL_BIT_FIELD_TYPE(NODE) \
(FIELD_DECL_CHECK (NODE)->field_decl.bit_field_type)
#define DECL_BIT_FIELD_REPRESENTATIVE(NODE) \
(FIELD_DECL_CHECK (NODE)->field_decl.qualifier)
#define DECL_QUALIFIER(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.qualifier)
#define DECL_OFFSET_ALIGN(NODE) \
(((unsigned HOST_WIDE_INT)1) << FIELD_DECL_CHECK (NODE)->decl_common.off_align)
#define SET_DECL_OFFSET_ALIGN(NODE, X) \
(FIELD_DECL_CHECK (NODE)->decl_common.off_align = ffs_hwi (X) - 1)
#define DECL_FCONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.fcontext)
#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->base.u.bits.packed_flag)
#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_1)
#define DECL_NONADDRESSABLE_P(NODE) \
(FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_2)
#define DECL_PADDING_P(NODE) \
(FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_3)
#define LABEL_DECL_UID(NODE) \
(LABEL_DECL_CHECK (NODE)->label_decl.label_decl_uid)
#define EH_LANDING_PAD_NR(NODE) \
(LABEL_DECL_CHECK (NODE)->label_decl.eh_landing_pad_nr)
#define DECL_ARG_TYPE(NODE) (PARM_DECL_CHECK (NODE)->decl_common.initial)
#define DECL_INCOMING_RTL(NODE) \
(PARM_DECL_CHECK (NODE)->parm_decl.incoming_rtl)
#define DECL_IN_SYSTEM_HEADER(NODE) \
(in_system_header_at (DECL_SOURCE_LOCATION (NODE)))
#define DECL_DEFER_OUTPUT(NODE) \
(DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.defer_output)
#define DECL_IN_TEXT_SECTION(NODE) \
(VAR_DECL_CHECK (NODE)->decl_with_vis.in_text_section)
#define DECL_IN_CONSTANT_POOL(NODE) \
(VAR_DECL_CHECK (NODE)->decl_with_vis.in_constant_pool)
#define DECL_COMMON(NODE) \
(DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.common_flag)
#define DECL_HARD_REGISTER(NODE)  \
(VAR_DECL_CHECK (NODE)->decl_with_vis.hard_register)
#define DECL_WEAK(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.weak_flag)
#define DECL_DLLIMPORT_P(NODE) \
(DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.dllimport_flag)
#define DECL_COMDAT(NODE) \
(DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.comdat_flag)
#define DECL_COMDAT_GROUP(NODE) \
decl_comdat_group (NODE)
#define DECL_ONE_ONLY(NODE) (DECL_COMDAT_GROUP (NODE) != NULL_TREE \
&& (TREE_PUBLIC (NODE) || DECL_EXTERNAL (NODE)))
#define DECL_ASSEMBLER_NAME(NODE) decl_assembler_name (NODE)
#define DECL_ASSEMBLER_NAME_RAW(NODE) \
(DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.assembler_name)
#define HAS_DECL_ASSEMBLER_NAME_P(NODE) \
(CODE_CONTAINS_STRUCT (TREE_CODE (NODE), TS_DECL_WITH_VIS))
#define DECL_ASSEMBLER_NAME_SET_P(NODE) \
(DECL_ASSEMBLER_NAME_RAW (NODE) != NULL_TREE)
#define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \
overwrite_decl_assembler_name (NODE, NAME)
#define COPY_DECL_ASSEMBLER_NAME(SRC_DECL, DST_DECL)			\
SET_DECL_ASSEMBLER_NAME (DST_DECL, DECL_ASSEMBLER_NAME_RAW (SRC_DECL))
#define DECL_SECTION_NAME(NODE) decl_section_name (NODE)
#define DECL_SEEN_IN_BIND_EXPR_P(NODE) \
(DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.seen_in_bind_expr)
#define DECL_VISIBILITY(NODE) \
(DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.visibility)
#define DECL_VISIBILITY_SPECIFIED(NODE) \
(DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.visibility_specified)
#define DECL_TLS_MODEL(NODE) decl_tls_model (NODE)
#define DECL_THREAD_LOCAL_P(NODE) \
((TREE_STATIC (NODE) || DECL_EXTERNAL (NODE)) && decl_tls_model (NODE) >= TLS_MODEL_REAL)
#define DECL_HAS_INIT_PRIORITY_P(NODE) \
(VAR_DECL_CHECK (NODE)->decl_with_vis.init_priority_p)
extern tree decl_debug_expr_lookup (tree);
extern void decl_debug_expr_insert (tree, tree);
#define DECL_HAS_DEBUG_EXPR_P(NODE) \
(VAR_DECL_CHECK (NODE)->decl_common.debug_expr_is_from)
#define DECL_DEBUG_EXPR(NODE) \
(decl_debug_expr_lookup (VAR_DECL_CHECK (NODE)))
#define SET_DECL_DEBUG_EXPR(NODE, VAL) \
(decl_debug_expr_insert (VAR_DECL_CHECK (NODE), VAL))
extern priority_type decl_init_priority_lookup (tree);
extern priority_type decl_fini_priority_lookup (tree);
extern void decl_init_priority_insert (tree, priority_type);
extern void decl_fini_priority_insert (tree, priority_type);
#define DECL_INIT_PRIORITY(NODE) \
(decl_init_priority_lookup (NODE))
#define SET_DECL_INIT_PRIORITY(NODE, VAL) \
(decl_init_priority_insert (NODE, VAL))
#define DECL_FINI_PRIORITY(NODE) \
(decl_fini_priority_lookup (NODE))
#define SET_DECL_FINI_PRIORITY(NODE, VAL) \
(decl_fini_priority_insert (NODE, VAL))
#define DEFAULT_INIT_PRIORITY 65535
#define MAX_INIT_PRIORITY 65535
#define MAX_RESERVED_INIT_PRIORITY 100
#define VAR_DECL_IS_VIRTUAL_OPERAND(NODE) \
(VAR_DECL_CHECK (NODE)->base.u.bits.saturating_flag)
#define DECL_NONLOCAL_FRAME(NODE)  \
(VAR_DECL_CHECK (NODE)->base.default_def_flag)
#define DECL_NONALIASED(NODE) \
(VAR_DECL_CHECK (NODE)->base.nothrow_flag)
#define DECL_RESULT_FLD(NODE) \
(DECL_NON_COMMON_CHECK (NODE)->decl_non_common.result)
#define DECL_VINDEX(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.vindex)
#define DECL_RESULT(NODE) (FUNCTION_DECL_CHECK (NODE)->decl_non_common.result)
#define DECL_UNINLINABLE(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.uninlinable)
#define DECL_SAVED_TREE(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.saved_tree)
#define DECL_IS_MALLOC(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.malloc_flag)
#define DECL_IS_OPERATOR_NEW(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.operator_new_flag)
#define DECL_IS_RETURNS_TWICE(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.returns_twice_flag)
#define DECL_PURE_P(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.pure_flag)
#define DECL_LOOPING_CONST_OR_PURE_P(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.looping_const_or_pure_flag)
#define DECL_IS_NOVOPS(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.novops_flag)
#define DECL_STATIC_CONSTRUCTOR(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.static_ctor_flag)
#define DECL_STATIC_DESTRUCTOR(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.static_dtor_flag)
#define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.no_instrument_function_entry_exit)
#define DECL_NO_LIMIT_STACK(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.no_limit_stack)
#define DECL_STATIC_CHAIN(NODE) \
(FUNCTION_DECL_CHECK (NODE)->decl_with_vis.regdecl_flag)
#define DECL_POSSIBLY_INLINED(DECL) \
FUNCTION_DECL_CHECK (DECL)->function_decl.possibly_inlined
#define DECL_DECLARED_INLINE_P(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.declared_inline_flag)
#define DECL_NO_INLINE_WARNING_P(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.no_inline_warning_flag)
#define BUILTIN_TM_LOAD_STORE_P(FN) \
((FN) >= BUILT_IN_TM_STORE_1 && (FN) <= BUILT_IN_TM_LOAD_RFW_LDOUBLE)
#define BUILTIN_TM_LOAD_P(FN) \
((FN) >= BUILT_IN_TM_LOAD_1 && (FN) <= BUILT_IN_TM_LOAD_RFW_LDOUBLE)
#define BUILTIN_TM_STORE_P(FN) \
((FN) >= BUILT_IN_TM_STORE_1 && (FN) <= BUILT_IN_TM_STORE_WAW_LDOUBLE)
#define CASE_BUILT_IN_TM_LOAD(FN)	\
case BUILT_IN_TM_LOAD_##FN:		\
case BUILT_IN_TM_LOAD_RAR_##FN:	\
case BUILT_IN_TM_LOAD_RAW_##FN:	\
case BUILT_IN_TM_LOAD_RFW_##FN
#define CASE_BUILT_IN_TM_STORE(FN)	\
case BUILT_IN_TM_STORE_##FN:		\
case BUILT_IN_TM_STORE_WAR_##FN:	\
case BUILT_IN_TM_STORE_WAW_##FN
#define DECL_DISREGARD_INLINE_LIMITS(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.disregard_inline_limits)
extern vec<tree, va_gc> **decl_debug_args_lookup (tree);
extern vec<tree, va_gc> **decl_debug_args_insert (tree);
#define DECL_HAS_DEBUG_ARGS_P(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.has_debug_args_flag)
#define DECL_STRUCT_FUNCTION(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.f)
#define DECL_BUILT_IN(NODE) (DECL_BUILT_IN_CLASS (NODE) != NOT_BUILT_IN)
#define DECL_BUILT_IN_CLASS(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.built_in_class)
#define DECL_ARGUMENTS(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.arguments)
#define DECL_FUNCTION_SPECIFIC_TARGET(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.function_specific_target)
#define DECL_FUNCTION_SPECIFIC_OPTIMIZATION(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.function_specific_optimization)
#define DECL_FUNCTION_VERSIONED(NODE)\
(FUNCTION_DECL_CHECK (NODE)->function_decl.versioned_function)
#define DECL_CXX_CONSTRUCTOR_P(NODE)\
(FUNCTION_DECL_CHECK (NODE)->decl_with_vis.cxx_constructor)
#define DECL_CXX_DESTRUCTOR_P(NODE)\
(FUNCTION_DECL_CHECK (NODE)->decl_with_vis.cxx_destructor)
#define DECL_LAMBDA_FUNCTION(NODE) \
(FUNCTION_DECL_CHECK (NODE)->function_decl.lambda_function)
#define DECL_FINAL_P(NODE)\
(FUNCTION_DECL_CHECK (NODE)->decl_with_vis.final)
#define TRANSLATION_UNIT_LANGUAGE(NODE) \
(TRANSLATION_UNIT_DECL_CHECK (NODE)->translation_unit_decl.language)
#define DECL_ORIGINAL_TYPE(NODE) \
(TYPE_DECL_CHECK (NODE)->decl_non_common.result)
#define TYPE_DECL_SUPPRESS_DEBUG(NODE) \
(TYPE_DECL_CHECK (NODE)->decl_common.decl_flag_1)
#define IMPORTED_DECL_ASSOCIATED_DECL(NODE) \
(DECL_INITIAL (IMPORTED_DECL_CHECK (NODE)))
#define NAMELIST_DECL_ASSOCIATED_DECL(NODE) \
(DECL_INITIAL (NODE))
#define STATEMENT_LIST_HEAD(NODE) \
(STATEMENT_LIST_CHECK (NODE)->stmt_list.head)
#define STATEMENT_LIST_TAIL(NODE) \
(STATEMENT_LIST_CHECK (NODE)->stmt_list.tail)
#define TREE_OPTIMIZATION(NODE) \
(OPTIMIZATION_NODE_CHECK (NODE)->optimization.opts)
#define TREE_OPTIMIZATION_OPTABS(NODE) \
(OPTIMIZATION_NODE_CHECK (NODE)->optimization.optabs)
#define TREE_OPTIMIZATION_BASE_OPTABS(NODE) \
(OPTIMIZATION_NODE_CHECK (NODE)->optimization.base_optabs)
extern tree build_optimization_node (struct gcc_options *opts);
#define TREE_TARGET_OPTION(NODE) \
(TARGET_OPTION_NODE_CHECK (NODE)->target_option.opts)
#define TREE_TARGET_GLOBALS(NODE) \
(TARGET_OPTION_NODE_CHECK (NODE)->target_option.globals)
extern tree build_target_option_node (struct gcc_options *opts);
extern void prepare_target_option_nodes_for_pch (void);
#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)
inline tree
tree_check (tree __t, const char *__f, int __l, const char *__g, tree_code __c)
{
if (TREE_CODE (__t) != __c)
tree_check_failed (__t, __f, __l, __g, __c, 0);
return __t;
}
inline tree
tree_not_check (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c)
{
if (TREE_CODE (__t) == __c)
tree_not_check_failed (__t, __f, __l, __g, __c, 0);
return __t;
}
inline tree
tree_check2 (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2)
{
if (TREE_CODE (__t) != __c1
&& TREE_CODE (__t) != __c2)
tree_check_failed (__t, __f, __l, __g, __c1, __c2, 0);
return __t;
}
inline tree
tree_not_check2 (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2)
{
if (TREE_CODE (__t) == __c1
|| TREE_CODE (__t) == __c2)
tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, 0);
return __t;
}
inline tree
tree_check3 (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)
{
if (TREE_CODE (__t) != __c1
&& TREE_CODE (__t) != __c2
&& TREE_CODE (__t) != __c3)
tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);
return __t;
}
inline tree
tree_not_check3 (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)
{
if (TREE_CODE (__t) == __c1
|| TREE_CODE (__t) == __c2
|| TREE_CODE (__t) == __c3)
tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);
return __t;
}
inline tree
tree_check4 (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
enum tree_code __c4)
{
if (TREE_CODE (__t) != __c1
&& TREE_CODE (__t) != __c2
&& TREE_CODE (__t) != __c3
&& TREE_CODE (__t) != __c4)
tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);
return __t;
}
inline tree
tree_not_check4 (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
enum tree_code __c4)
{
if (TREE_CODE (__t) == __c1
|| TREE_CODE (__t) == __c2
|| TREE_CODE (__t) == __c3
|| TREE_CODE (__t) == __c4)
tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);
return __t;
}
inline tree
tree_check5 (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
enum tree_code __c4, enum tree_code __c5)
{
if (TREE_CODE (__t) != __c1
&& TREE_CODE (__t) != __c2
&& TREE_CODE (__t) != __c3
&& TREE_CODE (__t) != __c4
&& TREE_CODE (__t) != __c5)
tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);
return __t;
}
inline tree
tree_not_check5 (tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
enum tree_code __c4, enum tree_code __c5)
{
if (TREE_CODE (__t) == __c1
|| TREE_CODE (__t) == __c2
|| TREE_CODE (__t) == __c3
|| TREE_CODE (__t) == __c4
|| TREE_CODE (__t) == __c5)
tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);
return __t;
}
inline tree
contains_struct_check (tree __t, const enum tree_node_structure_enum __s,
const char *__f, int __l, const char *__g)
{
if (tree_contains_struct[TREE_CODE (__t)][__s] != 1)
tree_contains_struct_check_failed (__t, __s, __f, __l, __g);
return __t;
}
inline tree
tree_class_check (tree __t, const enum tree_code_class __class,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE_CLASS (TREE_CODE (__t)) != __class)
tree_class_check_failed (__t, __class, __f, __l, __g);
return __t;
}
inline tree
tree_range_check (tree __t,
enum tree_code __code1, enum tree_code __code2,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) < __code1 || TREE_CODE (__t) > __code2)
tree_range_check_failed (__t, __f, __l, __g, __code1, __code2);
return __t;
}
inline tree
omp_clause_subcode_check (tree __t, enum omp_clause_code __code,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != OMP_CLAUSE)
tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
if (__t->omp_clause.code != __code)
omp_clause_check_failed (__t, __f, __l, __g, __code);
return __t;
}
inline tree
omp_clause_range_check (tree __t,
enum omp_clause_code __code1,
enum omp_clause_code __code2,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != OMP_CLAUSE)
tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
if ((int) __t->omp_clause.code < (int) __code1
|| (int) __t->omp_clause.code > (int) __code2)
omp_clause_range_check_failed (__t, __f, __l, __g, __code1, __code2);
return __t;
}
inline tree
expr_check (tree __t, const char *__f, int __l, const char *__g)
{
char const __c = TREE_CODE_CLASS (TREE_CODE (__t));
if (!IS_EXPR_CODE_CLASS (__c))
tree_class_check_failed (__t, tcc_expression, __f, __l, __g);
return __t;
}
inline tree
non_type_check (tree __t, const char *__f, int __l, const char *__g)
{
if (TYPE_P (__t))
tree_not_class_check_failed (__t, tcc_type, __f, __l, __g);
return __t;
}
inline const HOST_WIDE_INT *
tree_int_cst_elt_check (const_tree __t, int __i,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != INTEGER_CST)
tree_check_failed (__t, __f, __l, __g, INTEGER_CST, 0);
if (__i < 0 || __i >= __t->base.u.int_length.extended)
tree_int_cst_elt_check_failed (__i, __t->base.u.int_length.extended,
__f, __l, __g);
return &CONST_CAST_TREE (__t)->int_cst.val[__i];
}
inline HOST_WIDE_INT *
tree_int_cst_elt_check (tree __t, int __i,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != INTEGER_CST)
tree_check_failed (__t, __f, __l, __g, INTEGER_CST, 0);
if (__i < 0 || __i >= __t->base.u.int_length.extended)
tree_int_cst_elt_check_failed (__i, __t->base.u.int_length.extended,
__f, __l, __g);
return &CONST_CAST_TREE (__t)->int_cst.val[__i];
}
# if GCC_VERSION >= 4006
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-overflow"
#endif
inline tree *
tree_vec_elt_check (tree __t, int __i,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != TREE_VEC)
tree_check_failed (__t, __f, __l, __g, TREE_VEC, 0);
if (__i < 0 || __i >= __t->base.u.length)
tree_vec_elt_check_failed (__i, __t->base.u.length, __f, __l, __g);
return &CONST_CAST_TREE (__t)->vec.a[__i];
}
# if GCC_VERSION >= 4006
#pragma GCC diagnostic pop
#endif
inline tree *
omp_clause_elt_check (tree __t, int __i,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != OMP_CLAUSE)
tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
if (__i < 0 || __i >= omp_clause_num_ops [__t->omp_clause.code])
omp_clause_operand_check_failed (__i, __t, __f, __l, __g);
return &__t->omp_clause.ops[__i];
}
inline tree
any_integral_type_check (tree __t, const char *__f, int __l, const char *__g)
{
if (!ANY_INTEGRAL_TYPE_P (__t))
tree_check_failed (__t, __f, __l, __g, BOOLEAN_TYPE, ENUMERAL_TYPE,
INTEGER_TYPE, 0);
return __t;
}
inline const_tree
tree_check (const_tree __t, const char *__f, int __l, const char *__g,
tree_code __c)
{
if (TREE_CODE (__t) != __c)
tree_check_failed (__t, __f, __l, __g, __c, 0);
return __t;
}
inline const_tree
tree_not_check (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c)
{
if (TREE_CODE (__t) == __c)
tree_not_check_failed (__t, __f, __l, __g, __c, 0);
return __t;
}
inline const_tree
tree_check2 (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2)
{
if (TREE_CODE (__t) != __c1
&& TREE_CODE (__t) != __c2)
tree_check_failed (__t, __f, __l, __g, __c1, __c2, 0);
return __t;
}
inline const_tree
tree_not_check2 (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2)
{
if (TREE_CODE (__t) == __c1
|| TREE_CODE (__t) == __c2)
tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, 0);
return __t;
}
inline const_tree
tree_check3 (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)
{
if (TREE_CODE (__t) != __c1
&& TREE_CODE (__t) != __c2
&& TREE_CODE (__t) != __c3)
tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);
return __t;
}
inline const_tree
tree_not_check3 (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)
{
if (TREE_CODE (__t) == __c1
|| TREE_CODE (__t) == __c2
|| TREE_CODE (__t) == __c3)
tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);
return __t;
}
inline const_tree
tree_check4 (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
enum tree_code __c4)
{
if (TREE_CODE (__t) != __c1
&& TREE_CODE (__t) != __c2
&& TREE_CODE (__t) != __c3
&& TREE_CODE (__t) != __c4)
tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);
return __t;
}
inline const_tree
tree_not_check4 (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
enum tree_code __c4)
{
if (TREE_CODE (__t) == __c1
|| TREE_CODE (__t) == __c2
|| TREE_CODE (__t) == __c3
|| TREE_CODE (__t) == __c4)
tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);
return __t;
}
inline const_tree
tree_check5 (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
enum tree_code __c4, enum tree_code __c5)
{
if (TREE_CODE (__t) != __c1
&& TREE_CODE (__t) != __c2
&& TREE_CODE (__t) != __c3
&& TREE_CODE (__t) != __c4
&& TREE_CODE (__t) != __c5)
tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);
return __t;
}
inline const_tree
tree_not_check5 (const_tree __t, const char *__f, int __l, const char *__g,
enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
enum tree_code __c4, enum tree_code __c5)
{
if (TREE_CODE (__t) == __c1
|| TREE_CODE (__t) == __c2
|| TREE_CODE (__t) == __c3
|| TREE_CODE (__t) == __c4
|| TREE_CODE (__t) == __c5)
tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);
return __t;
}
inline const_tree
contains_struct_check (const_tree __t, const enum tree_node_structure_enum __s,
const char *__f, int __l, const char *__g)
{
if (tree_contains_struct[TREE_CODE (__t)][__s] != 1)
tree_contains_struct_check_failed (__t, __s, __f, __l, __g);
return __t;
}
inline const_tree
tree_class_check (const_tree __t, const enum tree_code_class __class,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE_CLASS (TREE_CODE (__t)) != __class)
tree_class_check_failed (__t, __class, __f, __l, __g);
return __t;
}
inline const_tree
tree_range_check (const_tree __t,
enum tree_code __code1, enum tree_code __code2,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) < __code1 || TREE_CODE (__t) > __code2)
tree_range_check_failed (__t, __f, __l, __g, __code1, __code2);
return __t;
}
inline const_tree
omp_clause_subcode_check (const_tree __t, enum omp_clause_code __code,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != OMP_CLAUSE)
tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
if (__t->omp_clause.code != __code)
omp_clause_check_failed (__t, __f, __l, __g, __code);
return __t;
}
inline const_tree
omp_clause_range_check (const_tree __t,
enum omp_clause_code __code1,
enum omp_clause_code __code2,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != OMP_CLAUSE)
tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
if ((int) __t->omp_clause.code < (int) __code1
|| (int) __t->omp_clause.code > (int) __code2)
omp_clause_range_check_failed (__t, __f, __l, __g, __code1, __code2);
return __t;
}
inline const_tree
expr_check (const_tree __t, const char *__f, int __l, const char *__g)
{
char const __c = TREE_CODE_CLASS (TREE_CODE (__t));
if (!IS_EXPR_CODE_CLASS (__c))
tree_class_check_failed (__t, tcc_expression, __f, __l, __g);
return __t;
}
inline const_tree
non_type_check (const_tree __t, const char *__f, int __l, const char *__g)
{
if (TYPE_P (__t))
tree_not_class_check_failed (__t, tcc_type, __f, __l, __g);
return __t;
}
# if GCC_VERSION >= 4006
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-overflow"
#endif
inline const_tree *
tree_vec_elt_check (const_tree __t, int __i,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != TREE_VEC)
tree_check_failed (__t, __f, __l, __g, TREE_VEC, 0);
if (__i < 0 || __i >= __t->base.u.length)
tree_vec_elt_check_failed (__i, __t->base.u.length, __f, __l, __g);
return CONST_CAST (const_tree *, &__t->vec.a[__i]);
}
# if GCC_VERSION >= 4006
#pragma GCC diagnostic pop
#endif
inline const_tree *
omp_clause_elt_check (const_tree __t, int __i,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != OMP_CLAUSE)
tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
if (__i < 0 || __i >= omp_clause_num_ops [__t->omp_clause.code])
omp_clause_operand_check_failed (__i, __t, __f, __l, __g);
return CONST_CAST (const_tree *, &__t->omp_clause.ops[__i]);
}
inline const_tree
any_integral_type_check (const_tree __t, const char *__f, int __l,
const char *__g)
{
if (!ANY_INTEGRAL_TYPE_P (__t))
tree_check_failed (__t, __f, __l, __g, BOOLEAN_TYPE, ENUMERAL_TYPE,
INTEGER_TYPE, 0);
return __t;
}
#endif
static inline int
tree_operand_length (const_tree node)
{
if (VL_EXP_CLASS_P (node))
return VL_EXP_OPERAND_LENGTH (node);
else
return TREE_CODE_LENGTH (TREE_CODE (node));
}
#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)
inline tree *
tree_operand_check (tree __t, int __i,
const char *__f, int __l, const char *__g)
{
const_tree __u = EXPR_CHECK (__t);
if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__u))
tree_operand_check_failed (__i, __u, __f, __l, __g);
return &CONST_CAST_TREE (__u)->exp.operands[__i];
}
inline tree *
tree_operand_check_code (tree __t, enum tree_code __code, int __i,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != __code)
tree_check_failed (__t, __f, __l, __g, __code, 0);
if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))
tree_operand_check_failed (__i, __t, __f, __l, __g);
return &__t->exp.operands[__i];
}
inline const_tree *
tree_operand_check (const_tree __t, int __i,
const char *__f, int __l, const char *__g)
{
const_tree __u = EXPR_CHECK (__t);
if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__u))
tree_operand_check_failed (__i, __u, __f, __l, __g);
return CONST_CAST (const_tree *, &__u->exp.operands[__i]);
}
inline const_tree *
tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,
const char *__f, int __l, const char *__g)
{
if (TREE_CODE (__t) != __code)
tree_check_failed (__t, __f, __l, __g, __code, 0);
if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))
tree_operand_check_failed (__i, __t, __f, __l, __g);
return CONST_CAST (const_tree *, &__t->exp.operands[__i]);
}
#endif
inline bool
id_equal (const_tree id, const char *str)
{
return !strcmp (IDENTIFIER_POINTER (id), str);
}
inline bool
id_equal (const char *str, const_tree id)
{
return !strcmp (str, IDENTIFIER_POINTER (id));
}
inline poly_uint64
TYPE_VECTOR_SUBPARTS (const_tree node)
{
STATIC_ASSERT (NUM_POLY_INT_COEFFS <= 2);
unsigned int precision = VECTOR_TYPE_CHECK (node)->type_common.precision;
if (NUM_POLY_INT_COEFFS == 2)
{
poly_uint64 res = 0;
res.coeffs[0] = 1 << (precision & 0xff);
if (precision & 0x100)
res.coeffs[1] = 1 << (precision & 0xff);
return res;
}
else
return 1 << precision;
}
inline void
SET_TYPE_VECTOR_SUBPARTS (tree node, poly_uint64 subparts)
{
STATIC_ASSERT (NUM_POLY_INT_COEFFS <= 2);
unsigned HOST_WIDE_INT coeff0 = subparts.coeffs[0];
int index = exact_log2 (coeff0);
gcc_assert (index >= 0);
if (NUM_POLY_INT_COEFFS == 2)
{
unsigned HOST_WIDE_INT coeff1 = subparts.coeffs[1];
gcc_assert (coeff1 == 0 || coeff1 == coeff0);
VECTOR_TYPE_CHECK (node)->type_common.precision
= index + (coeff1 != 0 ? 0x100 : 0);
}
else
VECTOR_TYPE_CHECK (node)->type_common.precision = index;
}
static inline bool
valid_vector_subparts_p (poly_uint64 subparts)
{
unsigned HOST_WIDE_INT coeff0 = subparts.coeffs[0];
if (!pow2p_hwi (coeff0))
return false;
if (NUM_POLY_INT_COEFFS == 2)
{
unsigned HOST_WIDE_INT coeff1 = subparts.coeffs[1];
if (coeff1 != 0 && coeff1 != coeff0)
return false;
}
return true;
}
#define EXPR_LOCATION_WRAPPER_P(NODE) \
(TREE_CHECK2(NODE, NON_LVALUE_EXPR, VIEW_CONVERT_EXPR)->base.public_flag)
inline bool
location_wrapper_p (const_tree exp)
{
if ((TREE_CODE (exp) == NON_LVALUE_EXPR
|| TREE_CODE (exp) == VIEW_CONVERT_EXPR)
&& EXPR_LOCATION_WRAPPER_P (exp))
return true;
return false;
}
inline tree
tree_strip_any_location_wrapper (tree exp)
{
if (location_wrapper_p (exp))
return TREE_OPERAND (exp, 0);
else
return exp;
}
#define error_mark_node			global_trees[TI_ERROR_MARK]
#define intQI_type_node			global_trees[TI_INTQI_TYPE]
#define intHI_type_node			global_trees[TI_INTHI_TYPE]
#define intSI_type_node			global_trees[TI_INTSI_TYPE]
#define intDI_type_node			global_trees[TI_INTDI_TYPE]
#define intTI_type_node			global_trees[TI_INTTI_TYPE]
#define unsigned_intQI_type_node	global_trees[TI_UINTQI_TYPE]
#define unsigned_intHI_type_node	global_trees[TI_UINTHI_TYPE]
#define unsigned_intSI_type_node	global_trees[TI_UINTSI_TYPE]
#define unsigned_intDI_type_node	global_trees[TI_UINTDI_TYPE]
#define unsigned_intTI_type_node	global_trees[TI_UINTTI_TYPE]
#define atomicQI_type_node	global_trees[TI_ATOMICQI_TYPE]
#define atomicHI_type_node	global_trees[TI_ATOMICHI_TYPE]
#define atomicSI_type_node	global_trees[TI_ATOMICSI_TYPE]
#define atomicDI_type_node	global_trees[TI_ATOMICDI_TYPE]
#define atomicTI_type_node	global_trees[TI_ATOMICTI_TYPE]
#define uint16_type_node		global_trees[TI_UINT16_TYPE]
#define uint32_type_node		global_trees[TI_UINT32_TYPE]
#define uint64_type_node		global_trees[TI_UINT64_TYPE]
#define void_node			global_trees[TI_VOID]
#define integer_zero_node		global_trees[TI_INTEGER_ZERO]
#define integer_one_node		global_trees[TI_INTEGER_ONE]
#define integer_three_node              global_trees[TI_INTEGER_THREE]
#define integer_minus_one_node		global_trees[TI_INTEGER_MINUS_ONE]
#define size_zero_node			global_trees[TI_SIZE_ZERO]
#define size_one_node			global_trees[TI_SIZE_ONE]
#define bitsize_zero_node		global_trees[TI_BITSIZE_ZERO]
#define bitsize_one_node		global_trees[TI_BITSIZE_ONE]
#define bitsize_unit_node		global_trees[TI_BITSIZE_UNIT]
#define access_public_node		global_trees[TI_PUBLIC]
#define access_protected_node	        global_trees[TI_PROTECTED]
#define access_private_node		global_trees[TI_PRIVATE]
#define null_pointer_node		global_trees[TI_NULL_POINTER]
#define float_type_node			global_trees[TI_FLOAT_TYPE]
#define double_type_node		global_trees[TI_DOUBLE_TYPE]
#define long_double_type_node		global_trees[TI_LONG_DOUBLE_TYPE]
#define FLOATN_TYPE_NODE(IDX)		global_trees[TI_FLOATN_TYPE_FIRST + (IDX)]
#define FLOATN_NX_TYPE_NODE(IDX)	global_trees[TI_FLOATN_NX_TYPE_FIRST + (IDX)]
#define FLOATNX_TYPE_NODE(IDX)		global_trees[TI_FLOATNX_TYPE_FIRST + (IDX)]
#define float16_type_node		global_trees[TI_FLOAT16_TYPE]
#define float32_type_node		global_trees[TI_FLOAT32_TYPE]
#define float64_type_node		global_trees[TI_FLOAT64_TYPE]
#define float128_type_node		global_trees[TI_FLOAT128_TYPE]
#define float32x_type_node		global_trees[TI_FLOAT32X_TYPE]
#define float64x_type_node		global_trees[TI_FLOAT64X_TYPE]
#define float128x_type_node		global_trees[TI_FLOAT128X_TYPE]
#define float_ptr_type_node		global_trees[TI_FLOAT_PTR_TYPE]
#define double_ptr_type_node		global_trees[TI_DOUBLE_PTR_TYPE]
#define long_double_ptr_type_node	global_trees[TI_LONG_DOUBLE_PTR_TYPE]
#define integer_ptr_type_node		global_trees[TI_INTEGER_PTR_TYPE]
#define complex_integer_type_node	global_trees[TI_COMPLEX_INTEGER_TYPE]
#define complex_float_type_node		global_trees[TI_COMPLEX_FLOAT_TYPE]
#define complex_double_type_node	global_trees[TI_COMPLEX_DOUBLE_TYPE]
#define complex_long_double_type_node	global_trees[TI_COMPLEX_LONG_DOUBLE_TYPE]
#define COMPLEX_FLOATN_NX_TYPE_NODE(IDX)	global_trees[TI_COMPLEX_FLOATN_NX_TYPE_FIRST + (IDX)]
#define pointer_bounds_type_node        global_trees[TI_POINTER_BOUNDS_TYPE]
#define void_type_node			global_trees[TI_VOID_TYPE]
#define ptr_type_node			global_trees[TI_PTR_TYPE]
#define const_ptr_type_node		global_trees[TI_CONST_PTR_TYPE]
#define size_type_node                  global_trees[TI_SIZE_TYPE]
#define pid_type_node                   global_trees[TI_PID_TYPE]
#define ptrdiff_type_node		global_trees[TI_PTRDIFF_TYPE]
#define va_list_type_node		global_trees[TI_VA_LIST_TYPE]
#define va_list_gpr_counter_field	global_trees[TI_VA_LIST_GPR_COUNTER_FIELD]
#define va_list_fpr_counter_field	global_trees[TI_VA_LIST_FPR_COUNTER_FIELD]
#define fileptr_type_node		global_trees[TI_FILEPTR_TYPE]
#define const_tm_ptr_type_node		global_trees[TI_CONST_TM_PTR_TYPE]
#define fenv_t_ptr_type_node		global_trees[TI_FENV_T_PTR_TYPE]
#define const_fenv_t_ptr_type_node	global_trees[TI_CONST_FENV_T_PTR_TYPE]
#define fexcept_t_ptr_type_node		global_trees[TI_FEXCEPT_T_PTR_TYPE]
#define const_fexcept_t_ptr_type_node	global_trees[TI_CONST_FEXCEPT_T_PTR_TYPE]
#define pointer_sized_int_node		global_trees[TI_POINTER_SIZED_TYPE]
#define boolean_type_node		global_trees[TI_BOOLEAN_TYPE]
#define boolean_false_node		global_trees[TI_BOOLEAN_FALSE]
#define boolean_true_node		global_trees[TI_BOOLEAN_TRUE]
#define dfloat32_type_node              global_trees[TI_DFLOAT32_TYPE]
#define dfloat64_type_node              global_trees[TI_DFLOAT64_TYPE]
#define dfloat128_type_node             global_trees[TI_DFLOAT128_TYPE]
#define dfloat32_ptr_type_node          global_trees[TI_DFLOAT32_PTR_TYPE]
#define dfloat64_ptr_type_node          global_trees[TI_DFLOAT64_PTR_TYPE]
#define dfloat128_ptr_type_node         global_trees[TI_DFLOAT128_PTR_TYPE]
#define sat_short_fract_type_node       global_trees[TI_SAT_SFRACT_TYPE]
#define sat_fract_type_node             global_trees[TI_SAT_FRACT_TYPE]
#define sat_long_fract_type_node        global_trees[TI_SAT_LFRACT_TYPE]
#define sat_long_long_fract_type_node   global_trees[TI_SAT_LLFRACT_TYPE]
#define sat_unsigned_short_fract_type_node \
global_trees[TI_SAT_USFRACT_TYPE]
#define sat_unsigned_fract_type_node    global_trees[TI_SAT_UFRACT_TYPE]
#define sat_unsigned_long_fract_type_node \
global_trees[TI_SAT_ULFRACT_TYPE]
#define sat_unsigned_long_long_fract_type_node \
global_trees[TI_SAT_ULLFRACT_TYPE]
#define short_fract_type_node           global_trees[TI_SFRACT_TYPE]
#define fract_type_node                 global_trees[TI_FRACT_TYPE]
#define long_fract_type_node            global_trees[TI_LFRACT_TYPE]
#define long_long_fract_type_node       global_trees[TI_LLFRACT_TYPE]
#define unsigned_short_fract_type_node  global_trees[TI_USFRACT_TYPE]
#define unsigned_fract_type_node        global_trees[TI_UFRACT_TYPE]
#define unsigned_long_fract_type_node   global_trees[TI_ULFRACT_TYPE]
#define unsigned_long_long_fract_type_node \
global_trees[TI_ULLFRACT_TYPE]
#define sat_short_accum_type_node       global_trees[TI_SAT_SACCUM_TYPE]
#define sat_accum_type_node             global_trees[TI_SAT_ACCUM_TYPE]
#define sat_long_accum_type_node        global_trees[TI_SAT_LACCUM_TYPE]
#define sat_long_long_accum_type_node   global_trees[TI_SAT_LLACCUM_TYPE]
#define sat_unsigned_short_accum_type_node \
global_trees[TI_SAT_USACCUM_TYPE]
#define sat_unsigned_accum_type_node    global_trees[TI_SAT_UACCUM_TYPE]
#define sat_unsigned_long_accum_type_node \
global_trees[TI_SAT_ULACCUM_TYPE]
#define sat_unsigned_long_long_accum_type_node \
global_trees[TI_SAT_ULLACCUM_TYPE]
#define short_accum_type_node           global_trees[TI_SACCUM_TYPE]
#define accum_type_node                 global_trees[TI_ACCUM_TYPE]
#define long_accum_type_node            global_trees[TI_LACCUM_TYPE]
#define long_long_accum_type_node       global_trees[TI_LLACCUM_TYPE]
#define unsigned_short_accum_type_node  global_trees[TI_USACCUM_TYPE]
#define unsigned_accum_type_node        global_trees[TI_UACCUM_TYPE]
#define unsigned_long_accum_type_node   global_trees[TI_ULACCUM_TYPE]
#define unsigned_long_long_accum_type_node \
global_trees[TI_ULLACCUM_TYPE]
#define qq_type_node                    global_trees[TI_QQ_TYPE]
#define hq_type_node                    global_trees[TI_HQ_TYPE]
#define sq_type_node                    global_trees[TI_SQ_TYPE]
#define dq_type_node                    global_trees[TI_DQ_TYPE]
#define tq_type_node                    global_trees[TI_TQ_TYPE]
#define uqq_type_node                   global_trees[TI_UQQ_TYPE]
#define uhq_type_node                   global_trees[TI_UHQ_TYPE]
#define usq_type_node                   global_trees[TI_USQ_TYPE]
#define udq_type_node                   global_trees[TI_UDQ_TYPE]
#define utq_type_node                   global_trees[TI_UTQ_TYPE]
#define sat_qq_type_node                global_trees[TI_SAT_QQ_TYPE]
#define sat_hq_type_node                global_trees[TI_SAT_HQ_TYPE]
#define sat_sq_type_node                global_trees[TI_SAT_SQ_TYPE]
#define sat_dq_type_node                global_trees[TI_SAT_DQ_TYPE]
#define sat_tq_type_node                global_trees[TI_SAT_TQ_TYPE]
#define sat_uqq_type_node               global_trees[TI_SAT_UQQ_TYPE]
#define sat_uhq_type_node               global_trees[TI_SAT_UHQ_TYPE]
#define sat_usq_type_node               global_trees[TI_SAT_USQ_TYPE]
#define sat_udq_type_node               global_trees[TI_SAT_UDQ_TYPE]
#define sat_utq_type_node               global_trees[TI_SAT_UTQ_TYPE]
#define ha_type_node                    global_trees[TI_HA_TYPE]
#define sa_type_node                    global_trees[TI_SA_TYPE]
#define da_type_node                    global_trees[TI_DA_TYPE]
#define ta_type_node                    global_trees[TI_TA_TYPE]
#define uha_type_node                   global_trees[TI_UHA_TYPE]
#define usa_type_node                   global_trees[TI_USA_TYPE]
#define uda_type_node                   global_trees[TI_UDA_TYPE]
#define uta_type_node                   global_trees[TI_UTA_TYPE]
#define sat_ha_type_node                global_trees[TI_SAT_HA_TYPE]
#define sat_sa_type_node                global_trees[TI_SAT_SA_TYPE]
#define sat_da_type_node                global_trees[TI_SAT_DA_TYPE]
#define sat_ta_type_node                global_trees[TI_SAT_TA_TYPE]
#define sat_uha_type_node               global_trees[TI_SAT_UHA_TYPE]
#define sat_usa_type_node               global_trees[TI_SAT_USA_TYPE]
#define sat_uda_type_node               global_trees[TI_SAT_UDA_TYPE]
#define sat_uta_type_node               global_trees[TI_SAT_UTA_TYPE]
#define void_list_node                  global_trees[TI_VOID_LIST_NODE]
#define main_identifier_node		global_trees[TI_MAIN_IDENTIFIER]
#define MAIN_NAME_P(NODE) \
(IDENTIFIER_NODE_CHECK (NODE) == main_identifier_node)
#define optimization_default_node	global_trees[TI_OPTIMIZATION_DEFAULT]
#define optimization_current_node	global_trees[TI_OPTIMIZATION_CURRENT]
#define target_option_default_node	global_trees[TI_TARGET_OPTION_DEFAULT]
#define target_option_current_node	global_trees[TI_TARGET_OPTION_CURRENT]
#define current_target_pragma		global_trees[TI_CURRENT_TARGET_PRAGMA]
#define current_optimize_pragma		global_trees[TI_CURRENT_OPTIMIZE_PRAGMA]
#define char_type_node			integer_types[itk_char]
#define signed_char_type_node		integer_types[itk_signed_char]
#define unsigned_char_type_node		integer_types[itk_unsigned_char]
#define short_integer_type_node		integer_types[itk_short]
#define short_unsigned_type_node	integer_types[itk_unsigned_short]
#define integer_type_node		integer_types[itk_int]
#define unsigned_type_node		integer_types[itk_unsigned_int]
#define long_integer_type_node		integer_types[itk_long]
#define long_unsigned_type_node		integer_types[itk_unsigned_long]
#define long_long_integer_type_node	integer_types[itk_long_long]
#define long_long_unsigned_type_node	integer_types[itk_unsigned_long_long]
#define error_operand_p(NODE)					\
((NODE) == error_mark_node					\
|| ((NODE) && TREE_TYPE ((NODE)) == error_mark_node))
inline unsigned int
vector_cst_encoded_nelts (const_tree t)
{
return VECTOR_CST_NPATTERNS (t) * VECTOR_CST_NELTS_PER_PATTERN (t);
}
extern tree decl_assembler_name (tree);
extern void overwrite_decl_assembler_name (tree decl, tree name);
extern tree decl_comdat_group (const_tree);
extern tree decl_comdat_group_id (const_tree);
extern const char *decl_section_name (const_tree);
extern void set_decl_section_name (tree, const char *);
extern enum tls_model decl_tls_model (const_tree);
extern void set_decl_tls_model (tree, enum tls_model);
extern size_t tree_size (const_tree);
extern size_t tree_code_size (enum tree_code);
extern int allocate_decl_uid (void);
extern tree make_node (enum tree_code CXX_MEM_STAT_INFO);
extern void free_node (tree);
extern tree copy_node (tree CXX_MEM_STAT_INFO);
extern tree copy_list (tree);
extern tree build_case_label (tree, tree, tree);
extern tree make_tree_binfo (unsigned CXX_MEM_STAT_INFO);
extern tree make_int_cst (int, int CXX_MEM_STAT_INFO);
extern tree make_tree_vec (int CXX_MEM_STAT_INFO);
extern tree grow_tree_vec (tree v, int CXX_MEM_STAT_INFO);
extern tree build_nt (enum tree_code, ...);
extern tree build_nt_call_vec (tree, vec<tree, va_gc> *);
extern tree build0 (enum tree_code, tree CXX_MEM_STAT_INFO);
extern tree build1 (enum tree_code, tree, tree CXX_MEM_STAT_INFO);
extern tree build2 (enum tree_code, tree, tree, tree CXX_MEM_STAT_INFO);
extern tree build3 (enum tree_code, tree, tree, tree, tree CXX_MEM_STAT_INFO);
extern tree build4 (enum tree_code, tree, tree, tree, tree,
tree CXX_MEM_STAT_INFO);
extern tree build5 (enum tree_code, tree, tree, tree, tree, tree,
tree CXX_MEM_STAT_INFO);
static inline tree
build1_loc (location_t loc, enum tree_code code, tree type,
tree arg1 CXX_MEM_STAT_INFO)
{
tree t = build1 (code, type, arg1 PASS_MEM_STAT);
if (CAN_HAVE_LOCATION_P (t))
SET_EXPR_LOCATION (t, loc);
return t;
}
static inline tree
build2_loc (location_t loc, enum tree_code code, tree type, tree arg0,
tree arg1 CXX_MEM_STAT_INFO)
{
tree t = build2 (code, type, arg0, arg1 PASS_MEM_STAT);
if (CAN_HAVE_LOCATION_P (t))
SET_EXPR_LOCATION (t, loc);
return t;
}
static inline tree
build3_loc (location_t loc, enum tree_code code, tree type, tree arg0,
tree arg1, tree arg2 CXX_MEM_STAT_INFO)
{
tree t = build3 (code, type, arg0, arg1, arg2 PASS_MEM_STAT);
if (CAN_HAVE_LOCATION_P (t))
SET_EXPR_LOCATION (t, loc);
return t;
}
static inline tree
build4_loc (location_t loc, enum tree_code code, tree type, tree arg0,
tree arg1, tree arg2, tree arg3 CXX_MEM_STAT_INFO)
{
tree t = build4 (code, type, arg0, arg1, arg2, arg3 PASS_MEM_STAT);
if (CAN_HAVE_LOCATION_P (t))
SET_EXPR_LOCATION (t, loc);
return t;
}
static inline tree
build5_loc (location_t loc, enum tree_code code, tree type, tree arg0,
tree arg1, tree arg2, tree arg3, tree arg4 CXX_MEM_STAT_INFO)
{
tree t = build5 (code, type, arg0, arg1, arg2, arg3,
arg4 PASS_MEM_STAT);
if (CAN_HAVE_LOCATION_P (t))
SET_EXPR_LOCATION (t, loc);
return t;
}
extern tree double_int_to_tree (tree, double_int);
extern tree wide_int_to_tree (tree type, const poly_wide_int_ref &cst);
extern tree force_fit_type (tree, const poly_wide_int_ref &, int, bool);
extern tree build_int_cst (tree, poly_int64);
extern tree build_int_cstu (tree type, poly_uint64);
extern tree build_int_cst_type (tree, poly_int64);
extern tree make_vector (unsigned, unsigned CXX_MEM_STAT_INFO);
extern tree build_vector_from_ctor (tree, vec<constructor_elt, va_gc> *);
extern tree build_vector_from_val (tree, tree);
extern tree build_vec_series (tree, tree, tree);
extern tree build_index_vector (tree, poly_uint64, poly_uint64);
extern void recompute_constructor_flags (tree);
extern void verify_constructor_flags (tree);
extern tree build_constructor (tree, vec<constructor_elt, va_gc> *);
extern tree build_constructor_single (tree, tree, tree);
extern tree build_constructor_from_list (tree, tree);
extern tree build_constructor_va (tree, int, ...);
extern tree build_real_from_int_cst (tree, const_tree);
extern tree build_complex (tree, tree, tree);
extern tree build_complex_inf (tree, bool);
extern tree build_each_one_cst (tree);
extern tree build_one_cst (tree);
extern tree build_minus_one_cst (tree);
extern tree build_all_ones_cst (tree);
extern tree build_zero_cst (tree);
extern tree build_string (int, const char *);
extern tree build_poly_int_cst (tree, const poly_wide_int_ref &);
extern tree build_tree_list (tree, tree CXX_MEM_STAT_INFO);
extern tree build_tree_list_vec (const vec<tree, va_gc> * CXX_MEM_STAT_INFO);
extern tree build_decl (location_t, enum tree_code,
tree, tree CXX_MEM_STAT_INFO);
extern tree build_fn_decl (const char *, tree);
extern tree build_translation_unit_decl (tree);
extern tree build_block (tree, tree, tree, tree);
extern tree build_empty_stmt (location_t);
extern tree build_omp_clause (location_t, enum omp_clause_code);
extern tree build_vl_exp (enum tree_code, int CXX_MEM_STAT_INFO);
extern tree build_call_nary (tree, tree, int, ...);
extern tree build_call_valist (tree, tree, int, va_list);
#define build_call_array(T1,T2,N,T3)\
build_call_array_loc (UNKNOWN_LOCATION, T1, T2, N, T3)
extern tree build_call_array_loc (location_t, tree, tree, int, const tree *);
extern tree build_call_vec (tree, tree, vec<tree, va_gc> *);
extern tree build_call_expr_loc_array (location_t, tree, int, tree *);
extern tree build_call_expr_loc_vec (location_t, tree, vec<tree, va_gc> *);
extern tree build_call_expr_loc (location_t, tree, int, ...);
extern tree build_call_expr (tree, int, ...);
extern tree build_call_expr_internal_loc (location_t, enum internal_fn,
tree, int, ...);
extern tree build_call_expr_internal_loc_array (location_t, enum internal_fn,
tree, int, const tree *);
extern tree maybe_build_call_expr_loc (location_t, combined_fn, tree,
int, ...);
extern tree build_alloca_call_expr (tree, unsigned int, HOST_WIDE_INT);
extern tree build_string_literal (int, const char *);
extern tree signed_or_unsigned_type_for (int, tree);
extern tree signed_type_for (tree);
extern tree unsigned_type_for (tree);
extern tree truth_type_for (tree);
extern tree build_pointer_type_for_mode (tree, machine_mode, bool);
extern tree build_pointer_type (tree);
extern tree build_reference_type_for_mode (tree, machine_mode, bool);
extern tree build_reference_type (tree);
extern tree build_vector_type_for_mode (tree, machine_mode);
extern tree build_vector_type (tree, poly_int64);
extern tree build_truth_vector_type (poly_uint64, poly_uint64);
extern tree build_same_sized_truth_vector_type (tree vectype);
extern tree build_opaque_vector_type (tree, poly_int64);
extern tree build_index_type (tree);
extern tree build_array_type (tree, tree, bool = false);
extern tree build_nonshared_array_type (tree, tree);
extern tree build_array_type_nelts (tree, poly_uint64);
extern tree build_function_type (tree, tree);
extern tree build_function_type_list (tree, ...);
extern tree build_varargs_function_type_list (tree, ...);
extern tree build_function_type_array (tree, int, tree *);
extern tree build_varargs_function_type_array (tree, int, tree *);
#define build_function_type_vec(RET, V) \
build_function_type_array (RET, vec_safe_length (V), vec_safe_address (V))
#define build_varargs_function_type_vec(RET, V) \
build_varargs_function_type_array (RET, vec_safe_length (V), \
vec_safe_address (V))
extern tree build_method_type_directly (tree, tree, tree);
extern tree build_method_type (tree, tree);
extern tree build_offset_type (tree, tree);
extern tree build_complex_type (tree, bool named = false);
extern tree array_type_nelts (const_tree);
extern tree value_member (tree, tree);
extern tree purpose_member (const_tree, tree);
extern bool vec_member (const_tree, vec<tree, va_gc> *);
extern tree chain_index (int, tree);
extern int tree_int_cst_equal (const_tree, const_tree);
extern bool tree_fits_shwi_p (const_tree) ATTRIBUTE_PURE;
extern bool tree_fits_poly_int64_p (const_tree) ATTRIBUTE_PURE;
extern bool tree_fits_uhwi_p (const_tree) ATTRIBUTE_PURE;
extern bool tree_fits_poly_uint64_p (const_tree) ATTRIBUTE_PURE;
extern HOST_WIDE_INT tree_to_shwi (const_tree);
extern poly_int64 tree_to_poly_int64 (const_tree);
extern unsigned HOST_WIDE_INT tree_to_uhwi (const_tree);
extern poly_uint64 tree_to_poly_uint64 (const_tree);
#if !defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 4003)
extern inline __attribute__ ((__gnu_inline__)) HOST_WIDE_INT
tree_to_shwi (const_tree t)
{
gcc_assert (tree_fits_shwi_p (t));
return TREE_INT_CST_LOW (t);
}
extern inline __attribute__ ((__gnu_inline__)) unsigned HOST_WIDE_INT
tree_to_uhwi (const_tree t)
{
gcc_assert (tree_fits_uhwi_p (t));
return TREE_INT_CST_LOW (t);
}
#if NUM_POLY_INT_COEFFS == 1
extern inline __attribute__ ((__gnu_inline__)) poly_int64
tree_to_poly_int64 (const_tree t)
{
gcc_assert (tree_fits_poly_int64_p (t));
return TREE_INT_CST_LOW (t);
}
extern inline __attribute__ ((__gnu_inline__)) poly_uint64
tree_to_poly_uint64 (const_tree t)
{
gcc_assert (tree_fits_poly_uint64_p (t));
return TREE_INT_CST_LOW (t);
}
#endif
#endif
extern int tree_int_cst_sgn (const_tree);
extern int tree_int_cst_sign_bit (const_tree);
extern unsigned int tree_int_cst_min_precision (tree, signop);
extern tree strip_array_types (tree);
extern tree excess_precision_type (tree);
extern bool valid_constant_size_p (const_tree);
inline bool
poly_int_tree_p (const_tree t, poly_int64_pod *value)
{
if (tree_fits_poly_int64_p (t))
{
*value = tree_to_poly_int64 (t);
return true;
}
return false;
}
inline bool
poly_int_tree_p (const_tree t, poly_uint64_pod *value)
{
if (tree_fits_poly_uint64_p (t))
{
*value = tree_to_poly_uint64 (t);
return true;
}
return false;
}
extern tree make_tree (tree, rtx);
extern bool check_lang_type (const_tree cand, const_tree base);
extern bool check_base_type (const_tree cand, const_tree base);
extern bool check_qualified_type (const_tree, const_tree, int);
extern tree get_qualified_type (tree, int);
extern tree build_qualified_type (tree, int CXX_MEM_STAT_INFO);
extern tree build_aligned_type (tree, unsigned int);
#define build_type_variant(TYPE, CONST_P, VOLATILE_P)			\
build_qualified_type ((TYPE),						\
((CONST_P) ? TYPE_QUAL_CONST : 0)		\
| ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))
extern tree build_distinct_type_copy (tree CXX_MEM_STAT_INFO);
extern tree build_variant_type_copy (tree CXX_MEM_STAT_INFO);
extern hashval_t type_hash_canon_hash (tree);
extern tree type_hash_canon (unsigned int, tree);
extern tree convert (tree, tree);
extern unsigned int expr_align (const_tree);
extern tree size_in_bytes_loc (location_t, const_tree);
inline tree
size_in_bytes (const_tree t)
{
return size_in_bytes_loc (input_location, t);
}
extern HOST_WIDE_INT int_size_in_bytes (const_tree);
extern HOST_WIDE_INT max_int_size_in_bytes (const_tree);
extern tree bit_position (const_tree);
extern tree byte_position (const_tree);
extern HOST_WIDE_INT int_byte_position (const_tree);
#define sizetype sizetype_tab[(int) stk_sizetype]
#define bitsizetype sizetype_tab[(int) stk_bitsizetype]
#define ssizetype sizetype_tab[(int) stk_ssizetype]
#define sbitsizetype sizetype_tab[(int) stk_sbitsizetype]
#define size_int(L) size_int_kind (L, stk_sizetype)
#define ssize_int(L) size_int_kind (L, stk_ssizetype)
#define bitsize_int(L) size_int_kind (L, stk_bitsizetype)
#define sbitsize_int(L) size_int_kind (L, stk_sbitsizetype)
#if BITS_PER_UNIT == 8
#define LOG2_BITS_PER_UNIT 3
#elif BITS_PER_UNIT == 16
#define LOG2_BITS_PER_UNIT 4
#else
#error Unknown BITS_PER_UNIT
#endif
extern tree chainon (tree, tree);
extern tree tree_cons (tree, tree, tree CXX_MEM_STAT_INFO);
extern tree tree_last (tree);
extern tree nreverse (tree);
extern int list_length (const_tree);
extern tree first_field (const_tree);
extern bool initializer_zerop (const_tree);
extern wide_int vector_cst_int_elt (const_tree, unsigned int);
extern tree vector_cst_elt (const_tree, unsigned int);
extern tree uniform_vector_p (const_tree);
extern vec<tree, va_gc> *ctor_to_vec (tree);
extern int zerop (const_tree);
extern int integer_zerop (const_tree);
extern int integer_onep (const_tree);
extern int integer_each_onep (const_tree);
extern int integer_all_onesp (const_tree);
extern int integer_minus_onep (const_tree);
extern int integer_pow2p (const_tree);
extern int integer_nonzerop (const_tree);
extern int integer_truep (const_tree);
extern bool cst_and_fits_in_hwi (const_tree);
extern tree num_ending_zeros (const_tree);
extern int fixed_zerop (const_tree);
extern tree staticp (tree);
extern tree save_expr (tree);
extern bool tree_invariant_p (tree);
extern tree skip_simple_arithmetic (tree);
extern tree skip_simple_constant_arithmetic (tree);
enum tree_node_structure_enum tree_node_structure (const_tree);
extern bool contains_placeholder_p (const_tree);
#define CONTAINS_PLACEHOLDER_P(EXP) \
((EXP) != 0 && ! TREE_CONSTANT (EXP) && contains_placeholder_p (EXP))
extern bool type_contains_placeholder_p (tree);
extern void find_placeholder_in_expr (tree, vec<tree> *);
#define FIND_PLACEHOLDER_IN_EXPR(EXP, V) \
do {					 \
if((EXP) && !TREE_CONSTANT (EXP))	 \
find_placeholder_in_expr (EXP, V);	 \
} while (0)
extern tree substitute_in_expr (tree, tree, tree);
#define SUBSTITUTE_IN_EXPR(EXP, F, R) \
((EXP) == 0 || TREE_CONSTANT (EXP) ? (EXP) : substitute_in_expr (EXP, F, R))
extern tree substitute_placeholder_in_expr (tree, tree);
#define SUBSTITUTE_PLACEHOLDER_IN_EXPR(EXP, OBJ) \
((EXP) == 0 || TREE_CONSTANT (EXP) ? (EXP)	\
: substitute_placeholder_in_expr (EXP, OBJ))
extern tree stabilize_reference (tree);
extern tree get_unwidened (tree, tree);
extern tree get_narrower (tree, int *);
static inline bool
handled_component_p (const_tree t)
{
switch (TREE_CODE (t))
{
case COMPONENT_REF:
case BIT_FIELD_REF:
case ARRAY_REF:
case ARRAY_RANGE_REF:
case REALPART_EXPR:
case IMAGPART_EXPR:
case VIEW_CONVERT_EXPR:
return true;
default:
return false;
}
}
static inline bool
reverse_storage_order_for_component_p (tree t)
{
if (AGGREGATE_TYPE_P (TREE_TYPE (t)) || VECTOR_TYPE_P (TREE_TYPE (t)))
return false;
if (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR)
t = TREE_OPERAND (t, 0);
switch (TREE_CODE (t))
{
case ARRAY_REF:
case COMPONENT_REF:
return AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0)))
&& TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_OPERAND (t, 0)));
case BIT_FIELD_REF:
case MEM_REF:
return REF_REVERSE_STORAGE_ORDER (t);
case ARRAY_RANGE_REF:
case VIEW_CONVERT_EXPR:
default:
return false;
}
gcc_unreachable ();
}
static inline bool
storage_order_barrier_p (const_tree t)
{
if (TREE_CODE (t) != VIEW_CONVERT_EXPR)
return false;
if (AGGREGATE_TYPE_P (TREE_TYPE (t))
&& TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (t)))
return true;
tree op = TREE_OPERAND (t, 0);
if (AGGREGATE_TYPE_P (TREE_TYPE (op))
&& TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (op)))
return true;
return false;
}
extern tree get_containing_scope (const_tree);
extern const_tree get_ultimate_context (const_tree);
extern tree decl_function_context (const_tree);
extern tree decl_type_context (const_tree);
extern int real_zerop (const_tree);
static inline void
function_args_iter_init (function_args_iterator *i, const_tree fntype)
{
i->next = TYPE_ARG_TYPES (fntype);
}
static inline tree *
function_args_iter_cond_ptr (function_args_iterator *i)
{
return (i->next) ? &TREE_VALUE (i->next) : NULL;
}
static inline tree
function_args_iter_cond (function_args_iterator *i)
{
return (i->next) ? TREE_VALUE (i->next) : NULL_TREE;
}
static inline void
function_args_iter_next (function_args_iterator *i)
{
gcc_assert (i->next != NULL_TREE);
i->next = TREE_CHAIN (i->next);
}
static inline bool
inlined_function_outer_scope_p (const_tree block)
{
return LOCATION_LOCUS (BLOCK_SOURCE_LOCATION (block)) != UNKNOWN_LOCATION;
}
#define FOREACH_FUNCTION_ARGS_PTR(FNTYPE, PTR, ITER)			\
for (function_args_iter_init (&(ITER), (FNTYPE));			\
(PTR = function_args_iter_cond_ptr (&(ITER))) != NULL;		\
function_args_iter_next (&(ITER)))
#define FOREACH_FUNCTION_ARGS(FNTYPE, TREE, ITER)			\
for (function_args_iter_init (&(ITER), (FNTYPE));			\
(TREE = function_args_iter_cond (&(ITER))) != NULL_TREE;		\
function_args_iter_next (&(ITER)))
extern unsigned crc32_unsigned_n (unsigned, unsigned, unsigned);
extern unsigned crc32_string (unsigned, const char *);
inline unsigned
crc32_unsigned (unsigned chksum, unsigned value)
{
return crc32_unsigned_n (chksum, value, 4);
}
inline unsigned
crc32_byte (unsigned chksum, char byte)
{
return crc32_unsigned_n (chksum, byte, 1);
}
extern void clean_symbol_name (char *);
extern tree get_file_function_name (const char *);
extern tree get_callee_fndecl (const_tree);
extern combined_fn get_call_combined_fn (const_tree);
extern int type_num_arguments (const_tree);
extern bool associative_tree_code (enum tree_code);
extern bool commutative_tree_code (enum tree_code);
extern bool commutative_ternary_tree_code (enum tree_code);
extern bool operation_can_overflow (enum tree_code);
extern bool operation_no_trapping_overflow (tree, enum tree_code);
extern tree upper_bound_in_type (tree, tree);
extern tree lower_bound_in_type (tree, tree);
extern int operand_equal_for_phi_arg_p (const_tree, const_tree);
extern tree create_artificial_label (location_t);
extern const char *get_name (tree);
extern bool stdarg_p (const_tree);
extern bool prototype_p (const_tree);
extern bool is_typedef_decl (const_tree x);
extern bool typedef_variant_p (const_tree);
extern bool auto_var_in_fn_p (const_tree, const_tree);
extern tree build_low_bits_mask (tree, unsigned);
extern bool tree_nop_conversion_p (const_tree, const_tree);
extern tree tree_strip_nop_conversions (tree);
extern tree tree_strip_sign_nop_conversions (tree);
extern const_tree strip_invariant_refs (const_tree);
extern tree lhd_gcc_personality (void);
extern void assign_assembler_name_if_needed (tree);
extern void warn_deprecated_use (tree, tree);
extern void cache_integer_cst (tree);
extern const char *combined_fn_name (combined_fn);
static inline int
struct_ptr_eq (const void *a, const void *b)
{
const void * const * x = (const void * const *) a;
const void * const * y = (const void * const *) b;
return *x == *y;
}
static inline hashval_t
struct_ptr_hash (const void *a)
{
const void * const * x = (const void * const *) a;
return (intptr_t)*x >> 4;
}
static inline bool
truth_value_p (enum tree_code code)
{
return (TREE_CODE_CLASS (code) == tcc_comparison
|| code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR
|| code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR
|| code == TRUTH_XOR_EXPR || code == TRUTH_NOT_EXPR);
}
static inline bool
ptrofftype_p (tree type)
{
return (INTEGRAL_TYPE_P (type)
&& TYPE_PRECISION (type) == TYPE_PRECISION (sizetype)
&& TYPE_UNSIGNED (type) == TYPE_UNSIGNED (sizetype));
}
static inline bool
complete_or_array_type_p (const_tree type)
{
return COMPLETE_TYPE_P (type)
|| (TREE_CODE (type) == ARRAY_TYPE
&& COMPLETE_TYPE_P (TREE_TYPE (type)));
}
inline bool
poly_int_tree_p (const_tree t)
{
return (TREE_CODE (t) == INTEGER_CST || POLY_INT_CST_P (t));
}
inline poly_uint64
bit_field_size (const_tree t)
{
return tree_to_poly_uint64 (TREE_OPERAND (t, 1));
}
inline poly_uint64
bit_field_offset (const_tree t)
{
return tree_to_poly_uint64 (TREE_OPERAND (t, 2));
}
extern tree strip_float_extensions (tree);
extern int really_constant_p (const_tree);
extern bool ptrdiff_tree_p (const_tree, poly_int64_pod *);
extern bool decl_address_invariant_p (const_tree);
extern bool decl_address_ip_invariant_p (const_tree);
extern bool int_fits_type_p (const_tree, const_tree);
#ifndef GENERATOR_FILE
extern void get_type_static_bounds (const_tree, mpz_t, mpz_t);
#endif
extern bool variably_modified_type_p (tree, tree);
extern int tree_log2 (const_tree);
extern int tree_floor_log2 (const_tree);
extern unsigned int tree_ctz (const_tree);
extern int simple_cst_equal (const_tree, const_tree);
namespace inchash
{
extern void add_expr (const_tree, hash &, unsigned int = 0);
}
static inline hashval_t iterative_hash_expr(const_tree tree, hashval_t seed)
{
inchash::hash hstate (seed);
inchash::add_expr (tree, hstate);
return hstate.end ();
}
extern int compare_tree_int (const_tree, unsigned HOST_WIDE_INT);
extern int type_list_equal (const_tree, const_tree);
extern int chain_member (const_tree, const_tree);
extern void dump_tree_statistics (void);
extern void recompute_tree_invariant_for_addr_expr (tree);
extern bool needs_to_live_in_memory (const_tree);
extern tree reconstruct_complex_type (tree, tree);
extern int real_onep (const_tree);
extern int real_minus_onep (const_tree);
extern void init_ttree (void);
extern void build_common_tree_nodes (bool);
extern void build_common_builtin_nodes (void);
extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);
extern tree build_nonstandard_boolean_type (unsigned HOST_WIDE_INT);
extern tree build_range_type (tree, tree, tree);
extern tree build_nonshared_range_type (tree, tree, tree);
extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);
extern HOST_WIDE_INT int_cst_value (const_tree);
extern tree tree_block (tree);
extern void tree_set_block (tree, tree);
extern location_t *block_nonartificial_location (tree);
extern location_t tree_nonartificial_location (tree);
extern tree block_ultimate_origin (const_tree);
extern tree get_binfo_at_offset (tree, poly_int64, tree);
extern bool virtual_method_call_p (const_tree);
extern tree obj_type_ref_class (const_tree ref);
extern bool types_same_for_odr (const_tree type1, const_tree type2,
bool strict=false);
extern bool contains_bitfld_component_ref_p (const_tree);
extern bool block_may_fallthru (const_tree);
extern void using_eh_for_cleanups (void);
extern bool using_eh_for_cleanups_p (void);
extern const char *get_tree_code_name (enum tree_code);
extern void set_call_expr_flags (tree, int);
extern tree walk_tree_1 (tree*, walk_tree_fn, void*, hash_set<tree>*,
walk_tree_lh);
extern tree walk_tree_without_duplicates_1 (tree*, walk_tree_fn, void*,
walk_tree_lh);
#define walk_tree(a,b,c,d) \
walk_tree_1 (a, b, c, d, NULL)
#define walk_tree_without_duplicates(a,b,c) \
walk_tree_without_duplicates_1 (a, b, c, NULL)
extern tree drop_tree_overflow (tree);
extern tree get_base_address (tree t);
extern tree array_ref_element_size (tree);
extern tree array_ref_up_bound (tree);
extern tree array_ref_low_bound (tree);
extern bool array_at_struct_end_p (tree);
extern tree component_ref_field_offset (tree);
extern int tree_map_base_eq (const void *, const void *);
extern unsigned int tree_map_base_hash (const void *);
extern int tree_map_base_marked_p (const void *);
extern void DEBUG_FUNCTION verify_type (const_tree t);
extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,
bool trust_type_canonical = true);
extern bool type_with_interoperable_signedness (const_tree);
extern bitmap get_nonnull_args (const_tree);
extern int get_range_pos_neg (tree);
inline enum tree_code
tree_code_for_canonical_type_merging (enum tree_code code)
{
if (code == ENUMERAL_TYPE)
return INTEGER_TYPE;
if (code == REFERENCE_TYPE)
return POINTER_TYPE;
return code;
}
inline bool
canonical_type_used_p (const_tree t)
{
return !(POINTER_TYPE_P (t)
|| TREE_CODE (t) == ARRAY_TYPE
|| TREE_CODE (t) == VECTOR_TYPE);
}
#define tree_map_eq tree_map_base_eq
extern unsigned int tree_map_hash (const void *);
#define tree_map_marked_p tree_map_base_marked_p
#define tree_decl_map_eq tree_map_base_eq
extern unsigned int tree_decl_map_hash (const void *);
#define tree_decl_map_marked_p tree_map_base_marked_p
struct tree_decl_map_cache_hasher : ggc_cache_ptr_hash<tree_decl_map>
{
static hashval_t hash (tree_decl_map *m) { return tree_decl_map_hash (m); }
static bool
equal (tree_decl_map *a, tree_decl_map *b)
{
return tree_decl_map_eq (a, b);
}
static int
keep_cache_entry (tree_decl_map *&m)
{
return ggc_marked_p (m->base.from);
}
};
#define tree_int_map_eq tree_map_base_eq
#define tree_int_map_hash tree_map_base_hash
#define tree_int_map_marked_p tree_map_base_marked_p
#define tree_vec_map_eq tree_map_base_eq
#define tree_vec_map_hash tree_decl_map_hash
#define tree_vec_map_marked_p tree_map_base_marked_p
struct tree_cache_traits
: simple_cache_map_traits<default_hash_traits<tree>, tree> { };
typedef hash_map<tree,tree,tree_cache_traits> tree_cache_map;
static inline void
init_call_expr_arg_iterator (tree exp, call_expr_arg_iterator *iter)
{
iter->t = exp;
iter->n = call_expr_nargs (exp);
iter->i = 0;
}
static inline void
init_const_call_expr_arg_iterator (const_tree exp, const_call_expr_arg_iterator *iter)
{
iter->t = exp;
iter->n = call_expr_nargs (exp);
iter->i = 0;
}
static inline tree
next_call_expr_arg (call_expr_arg_iterator *iter)
{
tree result;
if (iter->i >= iter->n)
return NULL_TREE;
result = CALL_EXPR_ARG (iter->t, iter->i);
iter->i++;
return result;
}
static inline const_tree
next_const_call_expr_arg (const_call_expr_arg_iterator *iter)
{
const_tree result;
if (iter->i >= iter->n)
return NULL_TREE;
result = CALL_EXPR_ARG (iter->t, iter->i);
iter->i++;
return result;
}
static inline tree
first_call_expr_arg (tree exp, call_expr_arg_iterator *iter)
{
init_call_expr_arg_iterator (exp, iter);
return next_call_expr_arg (iter);
}
static inline const_tree
first_const_call_expr_arg (const_tree exp, const_call_expr_arg_iterator *iter)
{
init_const_call_expr_arg_iterator (exp, iter);
return next_const_call_expr_arg (iter);
}
static inline bool
more_call_expr_args_p (const call_expr_arg_iterator *iter)
{
return (iter->i < iter->n);
}
#define FOR_EACH_CALL_EXPR_ARG(arg, iter, call)			\
for ((arg) = first_call_expr_arg ((call), &(iter)); (arg);	\
(arg) = next_call_expr_arg (&(iter)))
#define FOR_EACH_CONST_CALL_EXPR_ARG(arg, iter, call)			\
for ((arg) = first_const_call_expr_arg ((call), &(iter)); (arg);	\
(arg) = next_const_call_expr_arg (&(iter)))
static inline bool
is_lang_specific (const_tree t)
{
return TREE_CODE (t) == LANG_TYPE || TREE_CODE (t) >= NUM_TREE_CODES;
}
#define BUILTIN_VALID_P(FNCODE) \
(IN_RANGE ((int)FNCODE, ((int)BUILT_IN_NONE) + 1, ((int) END_BUILTINS) - 1))
static inline tree
builtin_decl_explicit (enum built_in_function fncode)
{
gcc_checking_assert (BUILTIN_VALID_P (fncode));
return builtin_info[(size_t)fncode].decl;
}
static inline tree
builtin_decl_implicit (enum built_in_function fncode)
{
size_t uns_fncode = (size_t)fncode;
gcc_checking_assert (BUILTIN_VALID_P (fncode));
if (!builtin_info[uns_fncode].implicit_p)
return NULL_TREE;
return builtin_info[uns_fncode].decl;
}
static inline void
set_builtin_decl (enum built_in_function fncode, tree decl, bool implicit_p)
{
size_t ufncode = (size_t)fncode;
gcc_checking_assert (BUILTIN_VALID_P (fncode)
&& (decl != NULL_TREE || !implicit_p));
builtin_info[ufncode].decl = decl;
builtin_info[ufncode].implicit_p = implicit_p;
builtin_info[ufncode].declared_p = false;
}
static inline void
set_builtin_decl_implicit_p (enum built_in_function fncode, bool implicit_p)
{
size_t uns_fncode = (size_t)fncode;
gcc_checking_assert (BUILTIN_VALID_P (fncode)
&& builtin_info[uns_fncode].decl != NULL_TREE);
builtin_info[uns_fncode].implicit_p = implicit_p;
}
static inline void
set_builtin_decl_declared_p (enum built_in_function fncode, bool declared_p)
{
size_t uns_fncode = (size_t)fncode;
gcc_checking_assert (BUILTIN_VALID_P (fncode)
&& builtin_info[uns_fncode].decl != NULL_TREE);
builtin_info[uns_fncode].declared_p = declared_p;
}
static inline bool
builtin_decl_explicit_p (enum built_in_function fncode)
{
gcc_checking_assert (BUILTIN_VALID_P (fncode));
return (builtin_info[(size_t)fncode].decl != NULL_TREE);
}
static inline bool
builtin_decl_implicit_p (enum built_in_function fncode)
{
size_t uns_fncode = (size_t)fncode;
gcc_checking_assert (BUILTIN_VALID_P (fncode));
return (builtin_info[uns_fncode].decl != NULL_TREE
&& builtin_info[uns_fncode].implicit_p);
}
static inline bool
builtin_decl_declared_p (enum built_in_function fncode)
{
size_t uns_fncode = (size_t)fncode;
gcc_checking_assert (BUILTIN_VALID_P (fncode));
return (builtin_info[uns_fncode].decl != NULL_TREE
&& builtin_info[uns_fncode].declared_p);
}
static inline bool
is_global_var (const_tree t)
{
return (TREE_STATIC (t) || DECL_EXTERNAL (t));
}
static inline bool
may_be_aliased (const_tree var)
{
return (TREE_CODE (var) != CONST_DECL
&& (TREE_PUBLIC (var)
|| DECL_EXTERNAL (var)
|| TREE_ADDRESSABLE (var))
&& !((TREE_STATIC (var) || TREE_PUBLIC (var) || DECL_EXTERNAL (var))
&& ((TREE_READONLY (var)
&& !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (var)))
|| (TREE_CODE (var) == VAR_DECL
&& DECL_NONALIASED (var)))));
}
static inline struct cl_optimization *
opts_for_fn (const_tree fndecl)
{
tree fn_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);
if (fn_opts == NULL_TREE)
fn_opts = optimization_default_node;
return TREE_OPTIMIZATION (fn_opts);
}
static inline cl_target_option *
target_opts_for_fn (const_tree fndecl)
{
tree fn_opts = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);
if (fn_opts == NULL_TREE)
fn_opts = target_option_default_node;
return fn_opts == NULL_TREE ? NULL : TREE_TARGET_OPTION (fn_opts);
}
#define opt_for_fn(fndecl, opt) (opts_for_fn (fndecl)->x_##opt)
extern const char *anon_aggrname_format();
extern bool anon_aggrname_p (const_tree);
namespace wi
{
class unextended_tree
{
private:
const_tree m_t;
public:
unextended_tree () {}
unextended_tree (const_tree t) : m_t (t) {}
unsigned int get_precision () const;
const HOST_WIDE_INT *get_val () const;
unsigned int get_len () const;
const_tree get_tree () const { return m_t; }
};
template <>
struct int_traits <unextended_tree>
{
static const enum precision_type precision_type = VAR_PRECISION;
static const bool host_dependent_precision = false;
static const bool is_sign_extended = false;
};
template <int N>
class extended_tree
{
private:
const_tree m_t;
public:
extended_tree () {}
extended_tree (const_tree);
unsigned int get_precision () const;
const HOST_WIDE_INT *get_val () const;
unsigned int get_len () const;
const_tree get_tree () const { return m_t; }
};
template <int N>
struct int_traits <extended_tree <N> >
{
static const enum precision_type precision_type = CONST_PRECISION;
static const bool host_dependent_precision = false;
static const bool is_sign_extended = true;
static const unsigned int precision = N;
};
typedef extended_tree <WIDE_INT_MAX_PRECISION> widest_extended_tree;
typedef extended_tree <ADDR_MAX_PRECISION> offset_extended_tree;
typedef const generic_wide_int <widest_extended_tree> tree_to_widest_ref;
typedef const generic_wide_int <offset_extended_tree> tree_to_offset_ref;
typedef const generic_wide_int<wide_int_ref_storage<false, false> >
tree_to_wide_ref;
tree_to_widest_ref to_widest (const_tree);
tree_to_offset_ref to_offset (const_tree);
tree_to_wide_ref to_wide (const_tree);
wide_int to_wide (const_tree, unsigned int);
typedef const poly_int <NUM_POLY_INT_COEFFS,
generic_wide_int <widest_extended_tree> >
tree_to_poly_widest_ref;
typedef const poly_int <NUM_POLY_INT_COEFFS,
generic_wide_int <offset_extended_tree> >
tree_to_poly_offset_ref;
typedef const poly_int <NUM_POLY_INT_COEFFS,
generic_wide_int <unextended_tree> >
tree_to_poly_wide_ref;
tree_to_poly_widest_ref to_poly_widest (const_tree);
tree_to_poly_offset_ref to_poly_offset (const_tree);
tree_to_poly_wide_ref to_poly_wide (const_tree);
template <int N>
struct ints_for <generic_wide_int <extended_tree <N> >, CONST_PRECISION>
{
typedef generic_wide_int <extended_tree <N> > extended;
static extended zero (const extended &);
};
template <>
struct ints_for <generic_wide_int <unextended_tree>, VAR_PRECISION>
{
typedef generic_wide_int <unextended_tree> unextended;
static unextended zero (const unextended &);
};
}
inline wi::tree_to_widest_ref
wi::to_widest (const_tree t)
{
return t;
}
inline wi::tree_to_offset_ref
wi::to_offset (const_tree t)
{
return t;
}
inline wi::tree_to_wide_ref
wi::to_wide (const_tree t)
{
return wi::storage_ref (&TREE_INT_CST_ELT (t, 0), TREE_INT_CST_NUNITS (t),
TYPE_PRECISION (TREE_TYPE (t)));
}
inline wide_int
wi::to_wide (const_tree t, unsigned int prec)
{
return wide_int::from (wi::to_wide (t), prec, TYPE_SIGN (TREE_TYPE (t)));
}
template <int N>
inline wi::extended_tree <N>::extended_tree (const_tree t)
: m_t (t)
{
gcc_checking_assert (TYPE_PRECISION (TREE_TYPE (t)) <= N);
}
template <int N>
inline unsigned int
wi::extended_tree <N>::get_precision () const
{
return N;
}
template <int N>
inline const HOST_WIDE_INT *
wi::extended_tree <N>::get_val () const
{
return &TREE_INT_CST_ELT (m_t, 0);
}
template <int N>
inline unsigned int
wi::extended_tree <N>::get_len () const
{
if (N == ADDR_MAX_PRECISION)
return TREE_INT_CST_OFFSET_NUNITS (m_t);
else if (N >= WIDE_INT_MAX_PRECISION)
return TREE_INT_CST_EXT_NUNITS (m_t);
else
gcc_unreachable ();
}
inline unsigned int
wi::unextended_tree::get_precision () const
{
return TYPE_PRECISION (TREE_TYPE (m_t));
}
inline const HOST_WIDE_INT *
wi::unextended_tree::get_val () const
{
return &TREE_INT_CST_ELT (m_t, 0);
}
inline unsigned int
wi::unextended_tree::get_len () const
{
return TREE_INT_CST_NUNITS (m_t);
}
inline wi::tree_to_poly_wide_ref
poly_int_cst_value (const_tree x)
{
poly_int <NUM_POLY_INT_COEFFS, generic_wide_int <wi::unextended_tree> > res;
for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)
res.coeffs[i] = POLY_INT_CST_COEFF (x, i);
return res;
}
inline wi::tree_to_poly_widest_ref
wi::to_poly_widest (const_tree t)
{
if (POLY_INT_CST_P (t))
{
poly_int <NUM_POLY_INT_COEFFS,
generic_wide_int <widest_extended_tree> > res;
for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)
res.coeffs[i] = POLY_INT_CST_COEFF (t, i);
return res;
}
return t;
}
inline wi::tree_to_poly_offset_ref
wi::to_poly_offset (const_tree t)
{
if (POLY_INT_CST_P (t))
{
poly_int <NUM_POLY_INT_COEFFS,
generic_wide_int <offset_extended_tree> > res;
for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)
res.coeffs[i] = POLY_INT_CST_COEFF (t, i);
return res;
}
return t;
}
inline wi::tree_to_poly_wide_ref
wi::to_poly_wide (const_tree t)
{
if (POLY_INT_CST_P (t))
return poly_int_cst_value (t);
return t;
}
template <int N>
inline generic_wide_int <wi::extended_tree <N> >
wi::ints_for <generic_wide_int <wi::extended_tree <N> >,
wi::CONST_PRECISION>::zero (const extended &x)
{
return build_zero_cst (TREE_TYPE (x.get_tree ()));
}
inline generic_wide_int <wi::unextended_tree>
wi::ints_for <generic_wide_int <wi::unextended_tree>,
wi::VAR_PRECISION>::zero (const unextended &x)
{
return build_zero_cst (TREE_TYPE (x.get_tree ()));
}
namespace wi
{
template <typename T>
bool fits_to_boolean_p (const T &x, const_tree);
template <typename T>
bool fits_to_tree_p (const T &x, const_tree);
wide_int min_value (const_tree);
wide_int max_value (const_tree);
wide_int from_mpz (const_tree, mpz_t, bool);
}
template <typename T>
bool
wi::fits_to_boolean_p (const T &x, const_tree type)
{
typedef typename poly_int_traits<T>::int_type int_type;
return (known_eq (x, int_type (0))
|| known_eq (x, int_type (TYPE_UNSIGNED (type) ? 1 : -1)));
}
template <typename T>
bool
wi::fits_to_tree_p (const T &x, const_tree type)
{
if (TREE_CODE (type) == BOOLEAN_TYPE)
return fits_to_boolean_p (x, type);
if (TYPE_UNSIGNED (type))
return known_eq (x, zext (x, TYPE_PRECISION (type)));
else
return known_eq (x, sext (x, TYPE_PRECISION (type)));
}
inline wide_int
wi::min_value (const_tree type)
{
return min_value (TYPE_PRECISION (type), TYPE_SIGN (type));
}
inline wide_int
wi::max_value (const_tree type)
{
return max_value (TYPE_PRECISION (type), TYPE_SIGN (type));
}
inline bool
tree_int_cst_lt (const_tree t1, const_tree t2)
{
return wi::to_widest (t1) < wi::to_widest (t2);
}
inline bool
tree_int_cst_le (const_tree t1, const_tree t2)
{
return wi::to_widest (t1) <= wi::to_widest (t2);
}
inline int
tree_int_cst_compare (const_tree t1, const_tree t2)
{
return wi::cmps (wi::to_widest (t1), wi::to_widest (t2));
}
extern void set_decl_rtl (tree, rtx);
extern bool complete_ctor_at_level_p (const_tree, HOST_WIDE_INT, const_tree);
extern tree get_inner_reference (tree, poly_int64_pod *, poly_int64_pod *,
tree *, machine_mode *, int *, int *, int *);
extern tree build_personality_function (const char *);
struct GTY(()) int_n_trees_t {
tree signed_type;
tree unsigned_type;
};
extern bool int_n_enabled_p[NUM_INT_N_ENTS];
extern GTY(()) struct int_n_trees_t int_n_trees[NUM_INT_N_ENTS];
inline HOST_WIDE_INT
int_bit_position (const_tree field)
{
return ((wi::to_offset (DECL_FIELD_OFFSET (field)) << LOG2_BITS_PER_UNIT)
+ wi::to_offset (DECL_FIELD_BIT_OFFSET (field))).to_shwi ();
}
inline bool
type_with_alias_set_p (const_tree t)
{
if (TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE)
return false;
if (COMPLETE_TYPE_P (t))
return true;
if (TREE_CODE (t) == ARRAY_TYPE && COMPLETE_TYPE_P (TREE_TYPE (t)))
return true;
return false;
}
extern location_t set_block (location_t loc, tree block);
extern void gt_ggc_mx (tree &);
extern void gt_pch_nx (tree &);
extern void gt_pch_nx (tree &, gt_pointer_operator, void *);
extern bool nonnull_arg_p (const_tree);
extern bool is_redundant_typedef (const_tree);
extern bool default_is_empty_record (const_tree);
extern HOST_WIDE_INT arg_int_size_in_bytes (const_tree);
extern tree arg_size_in_bytes (const_tree);
extern bool expr_type_first_operand_type_p (tree_code);
extern location_t
set_source_range (tree expr, location_t start, location_t finish);
extern location_t
set_source_range (tree expr, source_range src_range);
static inline source_range
get_decl_source_range (tree decl)
{
location_t loc = DECL_SOURCE_LOCATION (decl);
return get_range_from_loc (line_table, loc);
}
inline bool
desired_pro_or_demotion_p (const_tree to_type, const_tree from_type)
{
unsigned int to_type_precision = TYPE_PRECISION (to_type);
if (to_type_precision <= GET_MODE_PRECISION (word_mode))
return true;
return to_type_precision <= TYPE_PRECISION (from_type);
}
struct builtin_structptr_type
{
tree& node;
tree& base;
const char *str;
};
extern const builtin_structptr_type builtin_structptr_types[6];
inline bool
type_has_mode_precision_p (const_tree t)
{
return known_eq (TYPE_PRECISION (t), GET_MODE_PRECISION (TYPE_MODE (t)));
}
#endif  
