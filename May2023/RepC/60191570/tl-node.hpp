#ifndef TL_NODE_HPP
#define TL_NODE_HPP
#include <map>
#include "tl-induction-variables-data.hpp"
#include "tl-link-data.hpp"
#include "tl-nodecl-utils.hpp"
#include "tl-pcfg-utils.hpp"
#include "tl-ranges-common.hpp"
namespace TL  {
namespace Analysis {
typedef std::map<NBase, NBase, Nodecl::Utils::Nodecl_structural_less> RangeValuesMap;
class LIBTL_CLASS Node : public LinkData {
private:
unsigned int _id;
int _num;
NodeType _type;
Node* _outer_node;
EdgeList _entry_edges;
EdgeList _exit_edges;
bool _has_assertion;
bool _visited;
bool _visited_aux;
bool _visited_extgraph;     
bool _visited_extgraph_aux;
Node(const Node& n);
Node& operator=(const Node&);
template <typename T>
T get_vars(PCFGAttribute attr);
template <typename T>
void add_var_to_container(const NBase& var, PCFGAttribute attr);
template <typename T>
void add_vars_to_container(const T& vars, PCFGAttribute attr);
void add_var_to_list(const NBase& var, PCFGAttribute attr);
void add_vars_to_list(const Nodecl::List& vars, PCFGAttribute attr);
void remove_var_from_set(const NBase& var, PCFGAttribute attr);
public:
Node(unsigned int& id, NodeType type, Node* outer_node);
Node(unsigned int& id, NodeType type, Node* outer_node, const NodeclList& nodecls);
Node(unsigned int& id, NodeType type, Node* outer_node, const NBase& nodecl);
bool operator==(const Node& node) const;
unsigned int get_id() const;
void set_id(unsigned int id);
NodeType get_type() const;
void set_type(NodeType t);
inline std::string get_type_as_string() const
{
switch(_type)
{
#undef NODE_TYPE
#define NODE_TYPE(X) case __##X : return #X;
NODE_TYPE_LIST
#undef NODE_TYPE
default: WARNING_MESSAGE("Unexpected type of node '%d'", _type);
}
return "";
}
Node* get_outer_node() const;
void set_outer_node(Node* node);
const EdgeList& get_entry_edges() const;
void set_entry_edge(Edge *entry_edge);
EdgeTypeList get_entry_edge_types();
NodeclList get_entry_edge_labels();
NodeList get_parents();
const EdgeList& get_exit_edges() const;
void set_exit_edge(Edge *exit_edge);
EdgeTypeList get_exit_edge_types();
NodeclList get_exit_edge_labels();
Edge* get_exit_edge(Node* target);
NodeList get_children();
bool is_visited() const;
bool is_visited_aux() const;
bool is_visited_extgraph() const;
bool is_visited_extgraph_aux() const;
void set_visited(bool visited);
void set_visited_aux(bool visited);
void set_visited_extgraph(bool visited);
void set_visited_extgraph_aux(bool visited);
void set_num(int n);
int get_num() const;
std::string get_graph_type_as_string();
Node* get_graph_entry_node();
void set_graph_entry_node(Node* node);
Node* get_graph_exit_node();
void set_graph_exit_node(Node* node);
NBase get_graph_related_ast();
void set_graph_label(NBase n);
GraphType get_graph_type();
void set_graph_type(GraphType graph_type);
PCFGPragmaInfo get_pragma_node_info();
void set_pragma_node_info(const PCFGPragmaInfo& pragma);
bool has_statements();
NodeclList get_statements();
void set_statements(NodeclList stmts);
Symbol get_label();
void set_label(Symbol s);
ASM_node_info get_asm_info();
void set_asm_info(ASM_node_info inf);
bool has_usage_assertion() const;
bool has_upper_exposed_assertion() const;
bool has_defined_assertion() const;
bool has_undefined_assertion() const;
bool has_liveness_assertion() const;
bool has_live_in_assertion() const;
bool has_live_out_assertion() const;
bool has_dead_assertion() const;
bool has_reach_defs_assertion() const;
bool has_reach_defs_in_assertion() const;
bool has_reach_defs_out_assertion() const;
bool has_induction_vars_assertion() const;
bool has_autoscope_assertion() const;
bool has_autoscope_fp_assertion() const;
bool has_autoscope_p_assertion() const;
bool has_autoscope_s_assertion() const;
bool has_range_assertion() const;
bool has_correctness_assertion() const;
bool has_correctness_auto_storage_assertion() const;
bool has_correctness_incoherent_fp_assertion() const;
bool has_correctness_incoherent_p_assertion() const;
bool has_correctness_incoherent_in_assertion() const;
bool has_correctness_incoherent_in_pointed_assertion() const;
bool has_correctness_incoherent_out_assertion() const;
bool has_correctness_incoherent_out_pointed_assertion() const;
bool has_correctness_race_assertion() const;
bool has_correctness_dead_assertion() const;
void erase_entry_edge(Node* source);
void erase_exit_edge(Node* target);
bool node_is_enclosed_by(Node* potential_encloser);
bool is_builtin_node();
bool is_graph_node();
bool is_extended_graph_node();
bool is_entry_node();
bool is_exit_node();
bool is_function_code_node();
bool is_break_node();
bool is_conditional_expression();
bool is_continue_node();
bool is_context_node();
bool is_goto_node();
bool is_ifelse_statement();
bool is_switch_statement();
bool is_switch_case_node();
bool is_split_statement();
bool is_return_node();
bool is_unclassified_node();
bool is_graph_entry_node(Node* graph);
bool is_graph_exit_node(Node* graph);
bool is_loop_node();
bool is_for_loop();
bool is_while_loop();
bool is_do_loop();
bool is_normal_node();
bool is_labeled_node();
bool is_function_call_graph_node();
bool is_function_call_node();
bool is_asm_def_node();
bool is_asm_op_node();
bool is_omp_node();
bool is_omp_atomic_node();
bool is_omp_barrier_node();
bool is_omp_barrier_graph_node();
bool is_omp_critical_node();
bool is_omp_flush_node();
bool is_omp_loop_node();
bool is_omp_master_node();
bool is_omp_parallel_node();
bool is_omp_section_node();
bool is_omp_sections_node();
bool is_omp_simd_node();
bool is_omp_simd_function_node();
bool is_omp_single_node();
bool is_omp_workshare_node();
bool is_omp_task_node();
bool is_omp_task_creation_node();
bool is_omp_taskwait_node();
bool is_omp_async_target_node();
bool is_omp_sync_target_node();
bool is_ompss_taskwait_on_node();
bool is_omp_taskyield_node();
bool is_ompss_lint_node();
bool is_omp_virtual_tasksync();
bool is_vector_node();
bool has_child(Node* n);
bool has_parent(Node* n);
Symbol get_function_node_symbol();
NodeclSet get_private_vars();
NodeclSet get_firstprivate_vars();
NodeclSet get_lastprivate_vars();
NodeclSet get_all_private_vars();
NodeclSet get_all_shared_accesses();
bool has_verified_clause();
void add_verified_clause(const Nodecl::OmpSs::LintVerified& n);
AliveTaskSet& get_live_in_tasks();
AliveTaskSet& get_live_out_tasks();
NodeclSet& get_ue_vars();
void add_ue_var(const NBase& new_ue_var);
void add_ue_var(const NodeclSet& new_ue_vars);
void set_ue_var(const NodeclSet& new_ue_vars);
void remove_ue_var(const NBase& old_ue_var);
NodeclSet& get_private_ue_vars();
void add_private_ue_var(const NodeclSet& new_private_ue_vars);
void set_private_ue_var(const NodeclSet& new_private_ue_vars);
NodeclSet& get_killed_vars();
void add_killed_var(const NBase& new_killed_var);
void add_killed_var(const NodeclSet& new_killed_vars);
void set_killed_var(const NodeclSet& new_killed_vars);
void remove_killed_var(const NBase& old_killed_var);
NodeclSet& get_private_killed_vars();
void add_private_killed_var(const NodeclSet& new_private_killed_vars);
void set_private_killed_var(const NodeclSet& new_private_killed_vars);
NodeclSet& get_undefined_behaviour_vars();
void add_undefined_behaviour_var(const NBase& new_undef_var);
void add_undefined_behaviour_var_and_recompute_use_and_killed_sets(
const NBase& new_undef_var);
void set_undefined_behaviour_var(const NodeclSet& new_undef_vars);
void remove_undefined_behaviour_var(const NBase& old_undef_var);
NodeclSet& get_private_undefined_behaviour_vars();
void add_private_undefined_behaviour_var(const NodeclSet& new_private_undef_vars);
void set_private_undefined_behaviour_var(const NodeclSet& new_private_undef_vars);
NodeclSet& get_used_addresses();
void add_used_address(const NBase& es);
void set_used_addresses(const NodeclSet& used_addresses);
NodeclSet& get_live_in_vars();
void set_live_in(const NBase& new_live_in_var);
void set_live_in(const NodeclSet& new_live_in_set);
NodeclSet& get_live_out_vars();
void add_live_out(const NodeclSet& new_live_out_set);
void set_live_out(const NBase& new_live_out_var);
void set_live_out(const NodeclSet& new_live_out_set);
NodeclMap& get_generated_stmts();
void set_generated_stmts(const NodeclMap& gen);
NodeclMap& get_reaching_definitions_in();
NodeclMap& get_reaching_definitions_out();
void set_reaching_definition_in(const NBase& var, const NBase& init, const NBase& stmt);
void set_reaching_definitions_in(const NodeclMap& reach_defs_in);
void set_reaching_definition_out(const NBase& var, const NBase& init, const NBase& stmt);
void set_reaching_definitions_out(const NodeclMap& reach_defs_out);
Utils::InductionVarList& get_induction_variables();
void set_induction_variable(Utils::InductionVar* iv);
bool is_loop_induction_variable(const NBase& iv);
Node* get_condition_node();
void set_condition_node(Node* cond);
RangeValuesMap get_ranges();
NBase get_range(const NBase& var);
void set_range(const NBase& var, const NBase& value);
const NBase& get_task_context();
void set_task_context(NBase c);
Symbol get_task_function();
void set_task_function(Symbol func_sym);
bool is_auto_scoping_enabled();
void set_auto_scoping_enabled();
NodeclSet get_sc_shared_vars();
void set_sc_shared_var(NBase es);
void set_sc_shared_var(NodeclSet es_list);
NodeclSet get_sc_private_vars();
void set_sc_private_var(NBase es);
void set_sc_private_var(NodeclSet es_list);
NodeclSet get_sc_firstprivate_vars();
void set_sc_firstprivate_var(NBase es);
void set_sc_firstprivate_var(NodeclSet es_list);
NodeclSet get_sc_shared_or_firstprivate_vars();
void set_sc_shared_or_firstprivate_var(NBase es);
void set_sc_shared_or_firstprivate_var(NodeclSet es_list);
NodeclSet get_sc_undef_vars();
void set_sc_undef_var(NBase es);
void set_sc_undef_var(NodeclSet es_list);
NodeclSet get_sc_race_vars();
void set_sc_race_var(NBase es);
void set_sc_race_var(NodeclSet es_list);
Utils::AutoScopedVariables get_auto_scoped_variables();
NodeclSet get_deps_private_vars();
void set_deps_private_vars(NodeclSet new_deps_private_var);
NodeclSet get_deps_firstprivate_vars();
void set_deps_firstprivate_vars(NodeclSet new_deps_firstprivate_var);
NodeclSet get_deps_shared_vars();
void set_deps_shared_vars(NodeclSet new_deps_shared_var);
NodeclSet get_deps_in_exprs();
void set_deps_in_exprs(NodeclSet new_in_deps);
NodeclSet get_deps_out_exprs();
void set_deps_out_exprs(NodeclSet new_out_deps);
NodeclSet get_deps_inout_exprs();
void set_deps_inout_exprs(NodeclSet new_inout_deps);
NodeclSet get_deps_undef_vars();
void set_deps_undef_vars(NodeclSet new_undef_deps);
Nodecl::List get_correctness_auto_storage_vars();
void add_correctness_auto_storage_var(const Nodecl::NodeclBase& n);
Nodecl::List get_correctness_incoherent_fp_vars();
void add_correctness_incoherent_fp_var(const Nodecl::NodeclBase& n);
Nodecl::List get_correctness_incoherent_in_vars();
void add_correctness_incoherent_in_var(const Nodecl::NodeclBase& n);
Nodecl::List get_correctness_incoherent_in_pointed_vars();
void add_correctness_incoherent_in_pointed_var(const Nodecl::NodeclBase& n);
Nodecl::List get_correctness_incoherent_out_vars();
void add_correctness_incoherent_out_var(const Nodecl::NodeclBase& n);
Nodecl::List get_correctness_incoherent_out_pointed_vars();
void add_correctness_incoherent_out_pointed_var(const Nodecl::NodeclBase& n);
Nodecl::List get_correctness_incoherent_p_vars();
void add_correctness_incoherent_p_var(const Nodecl::NodeclBase& n);
NodeclTriboolMap get_correctness_race_vars();
Nodecl::List get_true_correctness_race_vars();
void add_correctness_race_var(const Nodecl::NodeclBase& n, tribool certainty);
Nodecl::List get_correctness_dead_vars();
void add_correctness_dead_var(const Nodecl::NodeclBase& n);
Nodecl::List get_correctness_unnecessarily_scoped_vars();
void add_correctness_unnecessarily_scoped_var(const Nodecl::NodeclBase& n);
ObjectList<Symbol> get_reductions();
ObjectList<Utils::LinearVars> get_linear_symbols();
ObjectList<Symbol> get_uniform_symbols();
NodeclSet get_assert_ue_vars();
void add_assert_ue_var(const Nodecl::List& new_assert_ue_vars);
NodeclSet get_assert_killed_vars();
void add_assert_killed_var(const Nodecl::List& new_assert_killed_vars);
NodeclSet get_assert_undefined_behaviour_vars();
void add_assert_undefined_behaviour_var(const Nodecl::List& new_assert_undefined_vars);
NodeclSet get_assert_live_in_vars();
void add_assert_live_in_var(const Nodecl::List& new_assert_live_in_vars);
NodeclSet get_assert_live_out_vars();
void add_assert_live_out_var(const Nodecl::List& new_assert_live_out_vars);
NodeclSet get_assert_dead_vars();
void add_assert_dead_var(const Nodecl::List& new_assert_dead_vars);
NodeclMap get_assert_reaching_definitions_in();
void add_assert_reaching_definitions_in(const Nodecl::List& new_assert_reach_defs_in);
NodeclMap get_assert_reaching_definitions_out();
void add_assert_reaching_definitions_out(const Nodecl::List& new_assert_reach_defs_out);
Utils::InductionVarList get_assert_induction_vars();
void add_assert_induction_variables(const Nodecl::List& new_assert_induction_vars);
NodeclSet get_assert_auto_sc_firstprivate_vars();
void add_assert_auto_sc_firstprivate_var(const Nodecl::List& new_assert_auto_sc_fp);
NodeclSet get_assert_auto_sc_private_vars();
void add_assert_auto_sc_private_var(const Nodecl::List& new_assert_auto_sc_p);
NodeclSet get_assert_auto_sc_shared_vars();
void add_assert_auto_sc_shared_var(const Nodecl::List& new_assert_auto_sc_s);
Utils::InductionVarList get_assert_ranges();
void add_assert_ranges(const Nodecl::List& new_assert_ranges);
Nodecl::List get_assert_correctness_auto_storage_vars();
void add_assert_correctness_auto_storage_var(const Nodecl::List& vars);
Nodecl::List get_assert_correctness_dead_vars();
void add_assert_correctness_dead_var(const Nodecl::List& vars);
Nodecl::List get_assert_correctness_incoherent_fp_vars();
void add_assert_correctness_incoherent_fp_var(const Nodecl::List& vars);
Nodecl::List get_assert_correctness_incoherent_in_vars();
void add_assert_correctness_incoherent_in_var(const Nodecl::List& vars);
Nodecl::List get_assert_correctness_incoherent_out_vars();
void add_assert_correctness_incoherent_out_var(const Nodecl::List& vars);
Nodecl::List get_assert_correctness_incoherent_p_vars();
void add_assert_correctness_incoherent_p_var(const Nodecl::List& vars);
Nodecl::List get_assert_correctness_incoherent_in_pointed_vars();
void add_assert_correctness_incoherent_in_pointed_var(const Nodecl::List& vars);
Nodecl::List get_assert_correctness_incoherent_out_pointed_vars();
void add_assert_correctness_incoherent_out_pointed_var(const Nodecl::List& vars);
Nodecl::List get_assert_correctness_race_vars();
void add_assert_correctness_race_var(const Nodecl::List& vars);
void print_use_def_chains();
void print_liveness();
void print_auto_scoping();
void print_task_dependencies();
};
}
}
#endif 
