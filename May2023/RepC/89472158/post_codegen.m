function [parmode, changed, has_emxutil] = post_codegen(func, cpath, m2c_opts)
%% Modify files generated by codegen
c_filename = [cpath, func, '.', m2c_opts.suf];
cfile_str = readFile(c_filename);
emxC_filename = [cpath, func, '_emxutil.', m2c_opts.suf];
if exist(emxC_filename, 'file')
emxC_str = readFile(emxC_filename);
has_emxutil = contains(cfile_str, 'emxCopyStruct_') && contains(emxC_str, 'emxCopyStruct_') || ...
contains(cfile_str, 'emxInitMatrix_') && contains(emxC_str, 'emxInitMatrix_') || ...
contains(cfile_str, 'emxInitStruct_') && contains(emxC_str, 'emxInitStruct_') || ...
contains(cfile_str, 'emxFreeStruct_') && contains(emxC_str, 'emxFreeStruct_');
emxH_filename = [cpath, func, '_emxutil.h'];
if exist(emxH_filename, 'file')
emxH_str = readFile(emxH_filename);
else
emxH_filename = '';
emxH_str = '';
end
else
has_emxutil = false;
end
h_filename = [cpath, func, '.h'];
hfile_str = readFile(h_filename);
ctype_filename = [cpath, func, '_types.h'];
ctypes_str = readFile(ctype_filename);
% Check whether the C file includes m2c.h
usem2c = ~isempty(regexp(cfile_str, '\n#include "m2c.h"', 'once'));
if has_emxutil
emxC_str_orig = emxC_str;
emxH_str_orig = emxH_str;
end
cfile_str_orig = cfile_str;
hfile_str_orig = hfile_str;
ctypes_str_orig = ctypes_str;
%% Move type declarations from C file to header file
% Remove definition of emxArray__common
pat = ['#ifndef\s+struct_emxArray__common\s+', ...
'#define\s+struct_emxArray__common\s+struct\s+emxArray__common\s+{[^}]+};\s+', ...
'#endif\s+#ifndef\s+typedef_emxArray__common\s+#define\s+typedef_emxArray__common\s+', ...
'typedef\s+struct\s+emxArray__common\s+', ...
'emxArray__common;\s+#endif\n'];
cfile_str = regexprep(cfile_str, pat, '');
ctypes_str = regexprep(ctypes_str, pat, '');
[cfile_str, type_def] = move_type_decl(cfile_str);
if ~isempty(type_def)
if m2c_opts.verbose
% Move type definitions
fprintf('M2C: API functions involves structures. Moved type definitions into header file %s_types.h\n', func);
end
if contains(ctypes_str, '', type_def, ...
'#endif', ''), '', api_decl], '', ...
'#endif', ''), '', ''));
type_def = comment(25:end-30);
else
% Move type declarations from C code to the _types.h header file.
pat = ['#ifndef\s+\w+\n+\#define\s+\w+\n+(typedef\s+struct\s+{([^}][^\n]+\n)+\}\s+\w+|', ...
'struct\s+\w+\s+\{([^}][^\n]+\n)+\};\n+#endif\n+', ...
'#ifndef\s+typedef_\w+\n+#define\s+\w+\n+typedef\s+struct\s+\w+\s+\w+);\n+#endif'];
types = regexp(cfile, pat, 'match');
type_def = '';
for i = 1:length(types)
cfile = strrep(cfile, types{i}, '');
type_def = sprintf('%s\n', type_def, types{i});
end
end
end
function [cfile_str, hfile_str] = move_emx_decl(cfile_str, hfile_str, public_types)
% Move emxFree_ and emxInit_ declarations from C code to the _types.h header file.
types = sprintf('%s|', public_types{:});
% Find declaration of emxInit_struct_T and and emxFree_struct_T
pat = ['\n\s*static\s+void\s+(emx(Init|Free)_struct_\w+)\s*\((', types(1:end-1), ')([^)]*)\);'];
emx_API = regexp(cfile_str, pat, 'match');
emx_decl = '';
for i = 1:length(emx_API)
func = regexprep(emx_API{i}, pat, '$1');
[cfile_str, emx_decl] = move_api_declaration(func, cfile_str, emx_decl);
cfile_str = change_api_definition(func, cfile_str);
fprintf('M2C: Moved helper function %s into header file\n', func);
end
hfile_str = strrep(hfile_str, ...
sprintf('\n#endif\n\n', emx_decl], '', ...
'#endif', ''), '/* End of code generation']);
end
