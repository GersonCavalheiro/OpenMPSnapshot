#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#define XWIDTH 256
#define YWIDTH 256
#define MAXVAL 65535
#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif
void center(int m, int n, int * x_center, int * y_center);
void meankernel(int m, int n, double * kernel){
double det = 1.0/(m*n);
int i, j;
for(i = 0; i < m; i++){
for(j = 0; j < n; j++){
kernel[i + m * j] = det;
}
}
}
void weightkernel(int m, int n, double param, int symm, double * kernel){
double w;
int i, j, x_center, y_center;
if (symm == 1){
center(m, n, &x_center, &y_center);
}
else{
x_center = (m-1)/2;
y_center = (n-1)/2;
}
w = (1-param)/(m * n - 1);
for(i = 0; i < m; i++){
for(j = 0; j < n; j++){
kernel[i + m * j] = w;
}
}
kernel[x_center + m * y_center] = param;
for (i = 0; i < m; i++) {
for (j = 0; j < n; j++) {
printf("%lf ", kernel[i + m * j]);
}
printf("\n");
}
}
void gaussiankernel(int m, int n, double param, int symm, double * kernel){
double sum = 0;
int i, j, x_center, y_center;
double den;
if (symm == 1){
center(m, n, &x_center, &y_center);
}
else{
x_center = (m-1)/2;
y_center = (n-1)/2;
}
if (param == 0){
kernel[x_center + m * y_center] = 1;
for (i = 0; i < m; i++) {
for (j = 0; j < n; j++) {
printf("%lf ", kernel[i + m * j]);
}
printf("\n");
}
return;
}
den = 1/(sqrt(2 * M_PI)*param);
param = param * param;
for (i = 0; i < m; i++) {
for (j = 0; j < n; j++) {
double x = i - x_center;
double y = j - y_center;
kernel[i + m * j] = den * exp(-(x * x + y * y) / (2 * param));
sum += kernel[i + m * j];
}
}
for (i = 0; i < m; i++) {
for (j = 0; j < n; j++) {
kernel[i + m * j] /= sum;
}
}
for (i = 0; i < m; i++) {
for (j = 0; j < n; j++) {
printf("%lf ", kernel[i + m * j]);
}
printf("\n");
}
}
void center(int m, int n, int * x_center, int * y_center){
printf("Enter an x value from 1 to %d \n", m);
while(*x_center < 1 || *x_center > m){
scanf("%d", x_center);
}
*x_center -= 1;
printf("Enter a y value from 1 to %d \n", n);
while(*y_center < 1 || *y_center > n){
scanf("%d", y_center);
}
*y_center -= 1;
return;
}
void elaborate(void * ptr, int xsize, int ysize, int maxval, double * kernel, int m, int n, void * res)
{
#pragma omp parallel
{
unsigned short int ind_i = (m - 1)/2;
unsigned short int ind_j = (n - 1)/2;
double val = 0;
double count = 0;
int i, j, ii, jj;
#pragma omp for private(val, count, j, ii, jj) schedule(dynamic)
for (i = 0; i < ysize; i++){
for (j = 0; j < xsize; j++){
for (ii = -ind_i; ii < ind_i + 1; ii++){
for (jj = -ind_j; jj < ind_j + 1; jj++){
if( (i + ii) < 0 || (i + ii) >= ysize || (j + jj) < 0 || (j + jj) >= xsize ){
count += kernel[(jj + ind_j) + n * (ii + ind_i)];
}
else{
val += ((unsigned short int *)ptr)[(j + jj) + xsize * (i + ii)] * kernel[(jj + ind_j) + n * (ii + ind_i)];
}
}
}
if (count != 0){
val /= (1-count);
}
((unsigned short int *)res)[j + xsize * i] = val;
val = 0;
count = 0;
}
} 
}
}
void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
{
FILE* image_file; 
image_file = fopen(image_name, "w"); 
int color_depth = 1 + ( maxval > 255 );
fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
fwrite( image, 1, xsize*ysize*color_depth, image_file);  
fclose(image_file); 
return ;
}
void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
{
FILE* image_file; 
image_file = fopen(image_name, "r"); 
*image = NULL;
*xsize = *ysize = *maxval = 0;
char    MagicN[2];
char   *line = NULL;
size_t  k, n = 0;
k = fscanf(image_file, "%2s%*c", MagicN );
k = getline( &line, &n, image_file);
while ( (k > 0) && (line[0]=='#') ){
k = getline( &line, &n, image_file);
}
if (k > 0)
{
k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
if ( k < 3 )
fscanf(image_file, "%d%*c", maxval);
}
else
{
*maxval = -1;         
free( line );
return;
}
free( line );
int color_depth = 1 + ( *maxval > 255 );
unsigned int size = *xsize * *ysize * color_depth;
if ( (*image = (char*)malloc( size )) == NULL )
{
fclose(image_file);
*maxval = -2;         
*xsize  = 0;
*ysize  = 0;
return;
}
if ( fread( *image, 1, size, image_file) != size )
{
free( image );
image   = NULL;
*maxval = -3;         
*xsize  = 0;
*ysize  = 0;
}  
fclose(image_file);
return;
}
void swap_image( void *image, int xsize, int ysize, int maxval )
{
if ( maxval > 255 )
{
int i;
unsigned int size = xsize * ysize;
for (i = 0; i < size; i+= 1 )
((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
}
return;
}
void * generate_gradient( int maxval, int xsize, int ysize )
{
char      *cImage;   
short int *sImage;   
void      *ptr;
int minval      = 0; 
int delta       = (maxval - minval) / ysize;
int yy, xx;
if(delta < 1 )
delta = 1;
if( maxval < 256 )
{
cImage = (char*)calloc( xsize*ysize, sizeof(char) );
unsigned char _maxval = (char)maxval;
int idx = 0;
for (yy = 0; yy < ysize; yy++ )
{
unsigned char value = minval + yy*delta;
for(xx = 0; xx < xsize; xx++ )
cImage[idx++] = (value > _maxval)?_maxval:value;
}
ptr = (void*)cImage;
}
else
{
sImage = (unsigned short int*)calloc( xsize*ysize, sizeof(short int) );
unsigned short int _maxval = swap((unsigned short int)maxval);
int idx = 0;
for (yy = 0; yy < ysize; yy++ )
{
unsigned short int value  = (short int) (minval+ yy*delta);
unsigned short int _value = swap( value );    
for(xx = 0; xx < xsize; xx++ )
sImage[idx++] = (value > maxval)?_maxval:_value;
}
ptr = (void*)sImage;  
}
return ptr;
}
